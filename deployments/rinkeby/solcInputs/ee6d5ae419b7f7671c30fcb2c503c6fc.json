{
  "language": "Solidity",
  "sources": {
    "contracts/access/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// Refer to https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringOwnable.sol and https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts/utils/Context.sol';\n\ncontract SafeOwnable is Context {\n  address private _owner;\n  address private _pendingOwner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() {\n    _transferOwnership(_msgSender());\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Return the address of the pending owner\n   */\n  function pendingOwner() public view virtual returns (address) {\n    return _pendingOwner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(owner() == _msgSender(), 'SafeOwnable: caller not owner');\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    _transferOwnership(address(0));\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   * Note If direct is false, it will set an pending owner and the OwnerShipTransferring\n   * only happens when the pending owner claim the ownership\n   */\n  function transferOwnership(address newOwner, bool direct) public virtual onlyOwner {\n    require(newOwner != address(0), 'SafeOwnable: new owner is 0');\n\n    if (direct) {\n      _transferOwnership(newOwner);\n    } else {\n      _transferPendingOwnership(newOwner);\n    }\n  }\n\n  /**\n   * @dev pending owner call this function to claim ownership\n   */\n  function claimOwnership() public {\n    require(msg.sender == _pendingOwner, 'SafeOwnable: caller != pending');\n\n    _claimOwnership();\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Internal function without access restriction.\n   */\n  function _transferOwnership(address newOwner) internal virtual {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n\n  /**\n   * @dev set the pending owner address\n   * Internal function without access restriction.\n   */\n  function _transferPendingOwnership(address newOwner) internal virtual {\n    _pendingOwner = newOwner;\n  }\n\n  /**\n   * @dev claim ownership of the contract to a new account (`newOwner`).\n   * Internal function without access restriction.\n   */\n  function _claimOwnership() internal virtual {\n    address oldOwner = _owner;\n    emit OwnershipTransferred(oldOwner, _pendingOwner);\n\n    _owner = _pendingOwner;\n    _pendingOwner = address(0);\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/token/VotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\n\nimport '../access/SafeOwnable.sol';\nimport './interfaces/IVotingEscrow.sol';\n\ncontract VotingEscrow is ReentrancyGuard, SafeOwnable, Pausable, IVotingEscrow {\n  using SafeERC20 for IERC20;\n  // all future times are rounded by week\n  uint256 constant WEEK = 7 * 86400;\n  // 4 years\n  uint256 constant MAXTIME = 4 * 365 * 86400;\n  uint256 constant MULTIPLIER = 10**18;\n\n  address public p12Token;\n  // total amount of locked P12token\n  uint256 public totalLockedP12;\n  mapping(address => LockedBalance) public locked;\n  uint256 public epoch;\n  bool public expired; // true if the contract end\n\n  mapping(uint256 => Point) public pointHistory;\n  mapping(address => mapping(uint256 => Point)) public userPointHistory;\n  mapping(address => uint256) public userPointEpoch;\n  mapping(uint256 => int256) public slopeChanges;\n\n  string public name;\n  string public symbol;\n  uint256 public constant decimals = 18;\n\n  enum OperationType {\n    DEPOSIT_FOR_TYPE,\n    CREATE_LOCK_TYPE,\n    INCREASE_LOCK_AMOUNT,\n    INCREASE_UNLOCK_TIME\n  }\n\n  event Expired(address addr, uint256 timestamp);\n  event Deposit(address indexed provider, uint256 value, uint256 indexed lockTime, OperationType t, uint256 ts);\n  event Withdraw(address indexed provider, uint256 value, uint256 ts);\n  event TotalLocked(uint256 prevTotalLockedP12, uint256 totalLockedP12);\n\n  struct Point {\n    int256 bias;\n    int256 slope;\n    uint256 ts;\n    uint256 blk;\n  }\n\n  struct LockedBalance {\n    int256 amount;\n    uint256 end;\n  }\n\n  struct CheckPointState {\n    int256 oldDslope;\n    int256 newDslope;\n    uint256 _epoch;\n  }\n\n  /** \n    @notice Contract constructor\n    @param p12TokenAddr_ `ERC20P12` token address\n    @param name_ Token name\n    @param symbol_ Token symbol\n  */\n  constructor(\n    address p12TokenAddr_,\n    string memory name_,\n    string memory symbol_\n  ) {\n    require(p12TokenAddr_ != address(0), 'VotingEscrow: token cannot be 0');\n    name = name_;\n    symbol = symbol_;\n    p12Token = p12TokenAddr_;\n    pointHistory[0].blk = block.number;\n    pointHistory[0].ts = block.timestamp;\n  }\n\n  function expire() external onlyOwner contractNotExpired {\n    expired = true;\n    emit Expired(msg.sender, block.timestamp);\n  }\n\n  /** \n    @notice Get the most recently recorded rate of voting power decrease for `addr`\n    @param addr Address of the user wallet\n    @return Value of the slope\n  */\n\n  function getLastUserSlope(address addr) external view returns (int256) {\n    uint256 uEpoch = userPointEpoch[addr];\n    return userPointHistory[addr][uEpoch].slope;\n  }\n\n  /** \n    @notice Get the timestamp for checkpoint `idx` for `addr`\n    @param addr User wallet address\n    @param idx User epoch number\n    @return Epoch time of the checkpoint\n  */\n  function userPointHistoryTs(address addr, uint256 idx) external view returns (uint256) {\n    return userPointHistory[addr][idx].ts;\n  }\n\n  /**\n    @notice Get timestamp when `addr`'s lock finishes\n    @param addr User wallet \n    @return Epoch time of the lock end\n  */\n  function lockedEnd(address addr) external view returns (uint256) {\n    return locked[addr].end;\n  }\n\n  /**\n    @notice Record global data to checkpoint\n  */\n  function checkPoint() external {\n    _checkPoint(address(0), LockedBalance({ amount: 0, end: 0 }), LockedBalance({ amount: 0, end: 0 }));\n  }\n\n  /**\n    @notice Deposit `value` tokens for `addr` and add to the lock\n    @dev Anyone (even a smart contract) can deposit for someone else, but\n         cannot extend their lockTime and deposit for a brand new user\n    @param addr User's wallet address\n    @param value Amount to add to user's lock  \n  */\n  function depositFor(address addr, uint256 value) external nonReentrant whenNotPaused contractNotExpired {\n    LockedBalance memory _locked = locked[addr];\n    require(value > 0, 'VotingEscrow: invalid value');\n    require(_locked.amount > 0, 'VotingEscrow: no existing lock');\n    require(_locked.end > block.timestamp, 'VotingEscrow: lock expired');\n    _depositFor(addr, value, 0, locked[addr], OperationType.DEPOSIT_FOR_TYPE);\n  }\n\n  /** \n    @notice Deposit `value` tokens for `msg.sender` and lock until `unlock_time`\n    @param value Amount to deposit\n    @param unlockTime Epoch time when tokens unlock, rounded down to whole weeks\n  */\n  function createLock(uint256 value, uint256 unlockTime) external nonReentrant whenNotPaused contractNotExpired {\n    //lockTime is rounded down to weeks\n    uint256 _unlockTime = (unlockTime / WEEK) * WEEK;\n    LockedBalance memory _locked = locked[msg.sender];\n    require(value > 0, 'VotingEscrow: invalid value');\n    require(_locked.amount == 0, 'VotingEscrow: old tokens locked');\n    require(_unlockTime > block.timestamp, 'VotingEscrow: lock later');\n    require(_unlockTime <= block.timestamp + MAXTIME, 'VotingEscrow: exceed cap period');\n    _depositFor(msg.sender, value, _unlockTime, _locked, OperationType.CREATE_LOCK_TYPE);\n  }\n\n  /**\n    @notice Deposit `value` additional tokens for `msg.sender`\n            without modifying the unlock time\n    @param value Amount of tokens to deposit and add to the lock\n  */\n  function increaseAmount(uint256 value) external nonReentrant whenNotPaused contractNotExpired {\n    LockedBalance memory _locked = locked[msg.sender];\n    require(value > 0, 'VotingEscrow: invalid value');\n    require(_locked.amount > 0, 'VotingEscrow: no existing lock');\n    require(_locked.end > block.timestamp, 'VotingEscrow: lock expired');\n    _depositFor(msg.sender, value, 0, _locked, OperationType.INCREASE_LOCK_AMOUNT);\n  }\n\n  /** \n    @notice Extend the unlock time for `msg.sender` to `unlock_time`\n    @param unlockTime New epoch time for unlocking\n  */\n  function increaseUnlockTime(uint256 unlockTime) external nonReentrant whenNotPaused contractNotExpired {\n    LockedBalance memory _locked = locked[msg.sender];\n    uint256 _unlockTime = (unlockTime / WEEK) * WEEK;\n    require(_locked.end > block.timestamp, 'VotingEscrow: Lock expired');\n    require(_locked.amount > 0, 'VotingEscrow: Nothing is locked');\n    require(_unlockTime > _locked.end, 'VotingEscrow: invalid unlockTime');\n    require(_unlockTime <= block.timestamp + MAXTIME, 'VotingEscrow: exceed cap period');\n    _depositFor(msg.sender, 0, _unlockTime, _locked, OperationType.INCREASE_LOCK_AMOUNT);\n  }\n\n  /** \n    @notice Withdraw all tokens for `msg.sender`\n    @dev Only possible if the lock has expired or contract expired\n  */\n  function withdraw() external nonReentrant whenNotPaused {\n    LockedBalance memory _locked = locked[msg.sender];\n    require(_locked.amount > 0, 'VotingEscrow: no locked token');\n    // Check if the contract is expired or unlocked\n    require(block.timestamp >= _locked.end || expired, 'VotingEscrow: condition not met');\n    uint256 value = uint256(_locked.amount);\n    LockedBalance memory oldLocked = _locked;\n    _locked.end = 0;\n    _locked.amount = 0;\n    locked[msg.sender] = _locked;\n    uint256 totalLockedP12Before = totalLockedP12;\n    totalLockedP12 = totalLockedP12Before - value;\n\n    // old_locked can have either expired <= timestamp or zero end\n    // _locked has only 0 end\n    // Both can have >= 0 amount\n\n    _checkPoint(msg.sender, oldLocked, _locked);\n    IERC20(p12Token).safeTransfer(msg.sender, value);\n\n    emit Withdraw(msg.sender, value, block.timestamp);\n    emit TotalLocked(totalLockedP12Before, totalLockedP12Before - value);\n  }\n\n  /** \n    @notice Get the current voting power for `msg.sender`\n    @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n    @param addr User wallet address\n    @return User voting power\n  */\n  function balanceOf(address addr) external view returns (int256) {\n    uint256 _epoch = userPointEpoch[addr];\n    if (_epoch == 0) {\n      return 0;\n    } else {\n      Point memory lastPoint = userPointHistory[addr][_epoch];\n      lastPoint.bias -= lastPoint.slope * int256(block.timestamp - lastPoint.ts);\n      if (lastPoint.bias < 0) {\n        lastPoint.bias = 0;\n      }\n      return lastPoint.bias;\n    }\n  }\n\n  /** \n    @notice Measure voting power of `addr` at block height `_block`\n    @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\n    @param addr User's wallet address\n    @param blk Block to calculate the voting power at\n    @return Voting power\n  */\n  function balanceOfAt(address addr, uint256 blk) external view returns (int256) {\n    require(blk <= block.number, 'VotingEscrow: invalid block');\n    // Binary search\n    uint256 _min = 0;\n    uint256 _max = userPointEpoch[addr];\n    for (uint256 i = 1; i <= 128; i++) {\n      if (_min >= _max) {\n        break;\n      }\n      uint256 _mid = (_min + _max + 1) / 2;\n      if (userPointHistory[addr][_mid].blk <= blk) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n    Point memory uPoint = userPointHistory[addr][_min];\n    uint256 maxEpoch = epoch;\n    uint256 _epoch = findBlockEpoch(blk, maxEpoch);\n    Point memory point0 = pointHistory[_epoch];\n    uint256 dBlock = 0;\n    uint256 dt = 0;\n    if (_epoch < maxEpoch) {\n      Point memory point1 = pointHistory[_epoch + 1];\n      dBlock = point1.blk - point0.blk;\n      dt = point1.ts - point0.ts;\n    } else {\n      dBlock = block.number - point0.blk;\n      dt = block.timestamp - point0.ts;\n    }\n    uint256 blockTime = point0.ts;\n    if (dBlock != 0) {\n      blockTime += (dt * (blk - point0.blk)) / dBlock;\n    }\n    uPoint.bias -= uPoint.slope * int256(blockTime - uPoint.ts);\n    if (uPoint.bias >= 0) {\n      return uPoint.bias;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   \n    @notice Calculate total voting power\n    @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n    @return Total voting power\n  \n  */\n\n  function totalSupply() external view returns (uint256) {\n    uint256 _epoch = epoch;\n    Point memory lastPoint = pointHistory[_epoch];\n    return supplyAt(lastPoint, block.timestamp);\n  }\n\n  /** \n    @notice Calculate total voting power at some point in the past\n    @param blk Block to calculate the total voting power at\n    @return Total voting power at `_block`\n  */\n  function totalSupplyAt(uint256 blk) external view returns (uint256) {\n    require(blk <= block.number, 'VotingEscrow: invalid block');\n    uint256 _epoch = epoch;\n    uint256 targetEpoch = findBlockEpoch(blk, _epoch);\n\n    Point memory point = pointHistory[targetEpoch];\n    uint256 dt = 0;\n    if (targetEpoch < _epoch) {\n      Point memory pointNext = pointHistory[targetEpoch + 1];\n      if (point.blk != pointNext.blk) {\n        dt = ((blk - point.blk) * (pointNext.ts - point.ts)) / (pointNext.blk - point.blk);\n      }\n    } else {\n      if (point.blk != block.number) {\n        dt = ((blk - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\n      }\n    }\n    // Now dt contains info on how far are we beyond point\n    return supplyAt(point, point.ts + dt);\n  }\n\n  //------------------public---------------\n\n  function pause() public onlyOwner {\n    _pause();\n  }\n\n  function unpause() public onlyOwner {\n    _unpause();\n  }\n\n  /** \n    @notice Binary search to estimate timestamp for block number\n    @param blk Block to find\n    @param maxEpoch Don't go beyond this epoch\n    @return Approximate timestamp for block\n  */\n\n  function findBlockEpoch(uint256 blk, uint256 maxEpoch) public view returns (uint256) {\n    uint256 _min = 0;\n    uint256 _max = maxEpoch;\n    for (uint256 i = 0; i <= 128; i++) {\n      if (_min >= _max) {\n        break;\n      }\n      uint256 _mid = (_min + _max + 1) / 2;\n      if (pointHistory[_mid].blk <= blk) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n    return _min;\n  }\n\n  // -------------internal------------------\n\n  /**\n    @notice Record global and per-user data to checkpoint\n    @param addr User's wallet address. No user checkpoint if 0x0\n    @param oldLocked Previous locked amount / end lock time for the user\n    @param newLocked New locked amount / end lock time for the user\n  */\n\n  function _checkPoint(\n    address addr,\n    LockedBalance memory oldLocked,\n    LockedBalance memory newLocked\n  ) internal {\n    Point memory uOld;\n    Point memory uNew;\n\n    CheckPointState memory cpState;\n    cpState.oldDslope = 0;\n    cpState.newDslope = 0;\n    cpState._epoch = epoch;\n    if (addr != address(0)) {\n      // Calculate slopes and biases\n      // Kept at zero when they have to\n      if (oldLocked.end > block.timestamp && oldLocked.amount > 0) {\n        uOld.slope = oldLocked.amount / int256(MAXTIME);\n        uOld.bias = uOld.slope * int256(oldLocked.end - block.timestamp);\n      }\n      if (newLocked.end > block.timestamp && newLocked.amount > 0) {\n        uNew.slope = newLocked.amount / int256(MAXTIME);\n        uNew.bias = uNew.slope * int256(newLocked.end - block.timestamp);\n      }\n      // Read values of scheduled changes in the slope\n      // old_locked.end can be in the past and in the future\n      // new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n\n      cpState.oldDslope = slopeChanges[oldLocked.end];\n      if (newLocked.end != 0) {\n        if (newLocked.end == oldLocked.end) {\n          cpState.newDslope = cpState.oldDslope;\n        } else {\n          cpState.newDslope = slopeChanges[newLocked.end];\n        }\n      }\n    }\n    Point memory lastPoint = Point(0, 0, block.timestamp, block.number);\n    if (cpState._epoch > 0) {\n      lastPoint = pointHistory[cpState._epoch];\n    }\n    uint256 lastCheckPoint = lastPoint.ts;\n    // initial_last_point is used for extrapolation to calculate block number\n    // (approximately, for *At methods) and save them\n    // as we cannot figure that out exactly from inside the contract\n\n    Point memory initialLastPoint = lastPoint;\n    uint256 blockSlope = 0;\n    if (block.timestamp > lastPoint.ts) {\n      blockSlope = (MULTIPLIER * (block.number - lastPoint.blk)) / (block.timestamp - lastPoint.ts);\n    }\n    // If last point is already recorded in this block, slope=0\n    // But that's ok b/c we know the block in such case\n\n    // Go over weeks to fill history and calculate what the current point is\n    uint256 ti = (lastCheckPoint / WEEK) * WEEK;\n\n    for (uint24 i = 0; i < 255; i++) {\n      ti += WEEK;\n      int256 dSlope = 0;\n      if (ti > block.timestamp) {\n        ti = block.timestamp;\n      } else {\n        dSlope = slopeChanges[ti];\n      }\n\n      lastPoint.bias -= lastPoint.slope * int256(ti - lastCheckPoint);\n      lastPoint.slope += dSlope;\n      if (lastPoint.bias < 0) {\n        lastPoint.bias = 0;\n      }\n      if (lastPoint.slope < 0) {\n        lastPoint.slope = 0;\n      }\n      lastCheckPoint = ti;\n      lastPoint.ts = ti;\n      lastPoint.blk = initialLastPoint.blk + (blockSlope * (ti - initialLastPoint.ts)) / MULTIPLIER;\n      cpState._epoch += 1;\n      if (ti == block.timestamp) {\n        lastPoint.blk = block.number;\n        break;\n      } else {\n        pointHistory[cpState._epoch] = lastPoint;\n      }\n    }\n    epoch = cpState._epoch;\n    // Now point_history is filled until t=now\n    if (addr != address(0)) {\n      // CalculateIf last point was in this block, the slope change has been applied already\n      // But in such case we have 0 slope(s)\n\n      lastPoint.slope += (uNew.slope - uOld.slope);\n      lastPoint.bias += (uNew.bias - uOld.bias);\n      if (lastPoint.slope < 0) {\n        lastPoint.slope = 0;\n      }\n      if (lastPoint.bias < 0) {\n        lastPoint.bias = 0;\n      }\n    }\n    // Record the changed point into history\n    pointHistory[cpState._epoch] = lastPoint;\n    if (addr != address(0)) {\n      // Schedule the slope changes (slope is going down)\n      // We subtract new_user_slope from [new_locked.end]\n      // and add old_user_slope to [old_locked.end]\n      if (oldLocked.end > block.timestamp) {\n        cpState.oldDslope += uOld.slope;\n        if (newLocked.end == oldLocked.end) {\n          cpState.oldDslope -= uNew.slope;\n        }\n        slopeChanges[oldLocked.end] = cpState.oldDslope;\n      }\n      if (newLocked.end > block.timestamp) {\n        if (newLocked.end > oldLocked.end) {\n          cpState.newDslope -= uNew.slope;\n          slopeChanges[newLocked.end] = cpState.newDslope;\n        }\n      }\n\n      // Now handle user history\n      uint256 userEpoch = userPointEpoch[addr] + 1;\n      userPointEpoch[addr] = userEpoch;\n      uNew.ts = block.timestamp;\n      uNew.blk = block.number;\n      userPointHistory[addr][userEpoch] = uNew;\n    }\n  }\n\n  /**\n    @notice Deposit and lock tokens for a user\n    @param addr User's wallet address\n    @param value Amount to deposit\n    @param unlockTime New time when to unlock the tokens, or 0 if unchanged\n    @param lockedBalance Previous locked amount / timestamp\n    @param t Operation type \n  */\n\n  function _depositFor(\n    address addr,\n    uint256 value,\n    uint256 unlockTime,\n    LockedBalance memory lockedBalance,\n    OperationType t\n  ) internal {\n    LockedBalance memory _locked = lockedBalance;\n    uint256 totalLockedP12Before = totalLockedP12;\n    totalLockedP12 = totalLockedP12Before + value;\n    LockedBalance memory oldLocked = LockedBalance({ amount: _locked.amount, end: _locked.end });\n    // Adding to existing lock, or if a lock is expired - creating a new one\n    _locked.amount += int256(value);\n    if (unlockTime != 0) {\n      _locked.end = unlockTime;\n    }\n    locked[addr] = _locked;\n    // Possibilities:\n    // Both old_locked.end could be current or expired (>/< block.timestamp)\n    // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n    // _locked.end > block.timestamp (always)\n\n    _checkPoint(addr, oldLocked, _locked);\n    if (value != 0) {\n      IERC20(p12Token).transferFrom(addr, address(this), value);\n    }\n    emit Deposit(addr, value, _locked.end, t, block.timestamp);\n    emit TotalLocked(totalLockedP12Before, totalLockedP12Before + value);\n  }\n\n  /** \n    @notice Calculate total voting power at some point in the past\n    @param point The point (bias/slope) to start search from\n    @param t Time to calculate the total voting power at\n    @return Total voting power at that time\n  */\n  function supplyAt(Point memory point, uint256 t) internal view returns (uint256) {\n    Point memory lastPoint = point;\n    uint256 ti = (lastPoint.ts / WEEK) * WEEK;\n    for (uint24 i = 0; i < 255; i++) {\n      ti += WEEK;\n      int256 dSlope = 0;\n      if (ti > t) {\n        ti = t;\n      } else {\n        dSlope = slopeChanges[ti];\n      }\n      lastPoint.bias -= lastPoint.slope * int256(ti - lastPoint.ts);\n      if (ti == t) {\n        break;\n      }\n      lastPoint.slope += dSlope;\n      lastPoint.ts = ti;\n    }\n    if (lastPoint.bias < 0) {\n      lastPoint.bias = 0;\n    }\n    return uint256(lastPoint.bias);\n  }\n\n  //------------modifier-------------\n\n  modifier contractNotExpired() {\n    require(!expired, 'VotingEscrow: contract stopped');\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/token/interfaces/IVotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\ninterface IVotingEscrow {\n  function getLastUserSlope(address addr) external returns (int256);\n\n  function lockedEnd(address addr) external returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/GaugeControllerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport './interfaces/IGaugeController.sol';\nimport '../token/interfaces/IVotingEscrow.sol';\nimport './ControllerStorage.sol';\nimport '../access/SafeOwnableUpgradeable.sol';\n\ncontract GaugeControllerUpgradeable is\n  ControllerStorage,\n  IGaugeController,\n  UUPSUpgradeable,\n  SafeOwnableUpgradeable,\n  PausableUpgradeable\n{\n  using Math for uint256;\n  // 7 * 86400 seconds - all future times are rounded by week\n  uint256 public constant WEEK = 604800;\n  uint256 public constant MULTIPLIER = 10**18;\n\n  // Cannot change weight votes more often than once in 10 days\n  uint256 public constant WEIGHT_VOTE_DELAY = 10 * 86400;\n\n  /**\n    @notice set new votingEscrow\n    @param newVotingEscrow address of votingEscrow\n   */\n  function setVotingEscrow(IVotingEscrow newVotingEscrow) external virtual override onlyOwner {\n    IVotingEscrow oldVotingEscrow = votingEscrow;\n    require(address(newVotingEscrow) != address(0), 'GC: ve can not 0');\n    votingEscrow = newVotingEscrow;\n    emit SetVotingEscrow(oldVotingEscrow, newVotingEscrow);\n  }\n\n  /**\n    @notice set new p12CoinFactory\n    @param newP12Factory address of newP12Factory\n   */\n  function setP12CoinFactory(address newP12Factory) external virtual override onlyOwner {\n    address oldP12Factory = p12CoinFactory;\n    require(newP12Factory != address(0), 'GC: ve can not 0');\n    p12CoinFactory = newP12Factory;\n    emit SetP12Factory(oldP12Factory, newP12Factory);\n  }\n\n  /**\n    @notice Get gauge type for address\n    @param addr Gauge address\n    @return Gauge type id\n  */\n  function getGaugeTypes(address addr) external view virtual override returns (int128) {\n    int128 gaugeType = gaugeTypes[addr];\n    require(gaugeType != 0, 'GC: wrong gauge type');\n    return gaugeType - 1;\n  }\n\n  /**\n    @notice Add gauge `addr` of type `gaugeType` with weight `weight`\n    @param addr Gauge address\n    @param gaugeType Gauge type\n    @param weight Gauge weight\n     */\n  function addGauge(\n    address addr,\n    int128 gaugeType,\n    uint256 weight\n  ) external virtual override {\n    require(msg.sender == owner() || msg.sender == address(p12CoinFactory), 'GC: only admin or p12CoinFactory');\n    require(gaugeType >= 0 && gaugeType < nGaugeTypes, 'GC: gaugeType error');\n    require(gaugeTypes[addr] == 0, 'GC: duplicated gauge type'); //dev: cannot add the same gauge twice\n\n    int128 n = nGauges;\n    nGauges = n + 1;\n    gauges[n] = addr;\n\n    gaugeTypes[addr] = gaugeType + 1;\n    uint256 nextTime = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n    if (weight > 0) {\n      uint256 typeWeight = _getTypeWeight(gaugeType);\n      uint256 oldSum = _getSum(gaugeType);\n      uint256 oldTotal = _getTotal();\n\n      pointsSum[gaugeType][nextTime].bias = weight + oldSum;\n      timeSum[gaugeType] = nextTime;\n      pointsTotal[nextTime] = oldTotal + typeWeight * weight;\n      timeTotal = nextTime;\n\n      pointsWeight[addr][nextTime].bias = weight;\n    }\n\n    if (timeSum[gaugeType] == 0) {\n      timeSum[gaugeType] = nextTime;\n    }\n    timeWeight[addr] = nextTime;\n\n    emit NewGauge(addr, gaugeType, weight);\n  }\n\n  /**\n    @notice Checkpoint to fill data common for all gauges\n     */\n  function checkpoint() external virtual override {\n    _getTotal();\n  }\n\n  /**\n    @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    @param addr Gauge address\n     */\n  function checkpointGauge(address addr) external virtual override {\n    _getWeight(addr);\n    _getTotal();\n  }\n\n  /**\n    @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n            (e.g. 1.0 == 1e18). Inflation which will be received by it is\n            inflation_rate * relative_weight / 1e18\n    @param addr Gauge address\n    @param time Relative weight at the specified timestamp in the past or present\n    @return Value of relative weight normalized to 1e18\n     */\n  function gaugeRelativeWeight(address addr, uint256 time) external view virtual override returns (uint256) {\n    return _gaugeRelativeWeight(addr, time);\n  }\n\n  /**\n    @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n        values for type and gauge records\n    @dev Any address can call, however nothing is recorded if the values are filled already\n    @param addr Gauge address\n    @param time Relative weight at the specified timestamp in the past or present\n    @return Value of relative weight normalized to 1e18\n     */\n  function gaugeRelativeWeightWrite(address addr, uint256 time) external virtual override returns (uint256) {\n    _getWeight(addr);\n    _getTotal(); // Also calculates get_sum\n    return _gaugeRelativeWeight(addr, time);\n  }\n\n  /**\n    @notice Add gauge type with name `name` and weight `weight`\n    @param name Name of gauge type\n    @param weight Weight of gauge type\n     */\n  function addType(string memory name, uint256 weight) external virtual override onlyOwner {\n    int128 typeId = nGaugeTypes;\n    gaugeTypeNames[typeId] = name;\n    nGaugeTypes = typeId + 1;\n    if (weight != 0) {\n      _changeTypeWeight(typeId, weight);\n      emit AddType(name, typeId);\n    }\n  }\n\n  /**\n    @notice Change gauge type `typeId` weight to `weight`\n    @param typeId Gauge type id\n    @param weight New Gauge weight\n     */\n  function changeTypeWeight(int128 typeId, uint256 weight) external virtual override onlyOwner {\n    _changeTypeWeight(typeId, weight);\n  }\n\n  /**\n    @notice Change weight of gauge `addr` to `weight`\n    @param addr `GaugeController` contract address\n    @param weight New Gauge weight\n     */\n  function changeGaugeWeight(address addr, uint256 weight) external virtual override onlyOwner {\n    _changeGaugeWeight(addr, weight);\n  }\n\n  /**\n        @notice Allocate voting power for changing pool weights\n        @param gaugeAddr Gauge which `msg.sender` votes for\n        @param userWeight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n     */\n  function voteForGaugeWeights(address gaugeAddr, uint256 userWeight) external virtual override whenNotPaused {\n    uint256 slope = uint256(votingEscrow.getLastUserSlope(msg.sender));\n    uint256 lockEnd = votingEscrow.lockedEnd(msg.sender);\n    uint256 nextTime = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n    require(lockEnd > nextTime, 'GC: no valid ve');\n    require(userWeight <= 10000, 'GC: no enough voting power');\n    require(block.timestamp >= lastUserVote[msg.sender][gaugeAddr] + WEIGHT_VOTE_DELAY, 'GC: Cannot vote so often');\n\n    TmpBias memory tmp1;\n    int128 gaugeType = gaugeTypes[gaugeAddr] - 1;\n    require(gaugeType >= 0, 'GC: Gauge not added');\n    // Prepare slopes and biases in memory\n    VotedSlope memory oldSlope = voteUserSlopes[msg.sender][gaugeAddr];\n    uint256 oldDt = 0;\n    if (oldSlope.end > nextTime) {\n      oldDt = oldSlope.end - nextTime;\n    }\n    tmp1.oldBias = oldSlope.slope * oldDt;\n    VotedSlope memory newSlope = VotedSlope({ slope: (slope * userWeight) / 10000, end: lockEnd, power: userWeight });\n    uint256 newDt = lockEnd - nextTime; // dev: raises when expired\n    tmp1.newBias = newSlope.slope * newDt;\n\n    // Check and update powers (weights) used\n    voteUserPower[msg.sender] = voteUserPower[msg.sender] + newSlope.power - oldSlope.power;\n    require(voteUserPower[msg.sender] <= 10000, 'GC: Used too much power');\n\n    // Remove old and schedule new slope changes\n    // Remove slope changes for old slopes\n    // Schedule recording of initial slope for nextTime\n\n    {\n      TmpBiasAndSlope memory tmp2;\n      tmp2.oldWeightBias = _getWeight(gaugeAddr);\n      tmp2.oldWeightSlope = pointsWeight[gaugeAddr][nextTime].slope;\n      tmp2.oldSumBias = _getSum(gaugeType);\n      tmp2.oldSumSlope = pointsSum[gaugeType][nextTime].slope;\n\n      pointsWeight[gaugeAddr][nextTime].bias = Math.max(tmp2.oldWeightBias + tmp1.newBias, tmp1.oldBias) - tmp1.oldBias;\n      pointsSum[gaugeType][nextTime].bias = Math.max(tmp2.oldSumBias + tmp1.newBias, tmp1.oldBias) - tmp1.oldBias;\n      if (oldSlope.end > nextTime) {\n        pointsWeight[gaugeAddr][nextTime].slope =\n          Math.max(tmp2.oldWeightSlope + newSlope.slope, oldSlope.slope) -\n          oldSlope.slope;\n        pointsSum[gaugeType][nextTime].slope = Math.max(tmp2.oldSumSlope + newSlope.slope, oldSlope.slope) - oldSlope.slope;\n      } else {\n        pointsWeight[gaugeAddr][nextTime].slope += newSlope.slope;\n        pointsSum[gaugeType][nextTime].slope += newSlope.slope;\n      }\n    }\n\n    if (oldSlope.end > block.timestamp) {\n      // Cancel old slope changes if they still didn't happen\n      changesWeight[gaugeAddr][oldSlope.end] -= oldSlope.slope;\n      changesSum[gaugeType][oldSlope.end] -= oldSlope.slope;\n    }\n\n    // Add slope changes for new slopes\n\n    changesWeight[gaugeAddr][newSlope.end] += newSlope.slope;\n    changesSum[gaugeType][newSlope.end] += newSlope.slope;\n\n    _getTotal();\n\n    voteUserSlopes[msg.sender][gaugeAddr] = newSlope;\n\n    // Record last action time\n    lastUserVote[msg.sender][gaugeAddr] = block.timestamp;\n    emit VoteForGauge(block.timestamp, msg.sender, gaugeAddr, userWeight);\n  }\n\n  /**\n        @notice Get current gauge weight\n        @param addr Gauge address\n        @return Gauge weight\n     */\n  function getGaugeWeight(address addr) external view virtual override returns (uint256) {\n    return pointsWeight[addr][timeWeight[addr]].bias;\n  }\n\n  /**\n      @notice Get current type weight\n      @param typeId Type id\n      @return Type weight\n     */\n  function getTypeWeight(int128 typeId) external view virtual override returns (uint256) {\n    return pointsTypeWeight[typeId][timeTypeWeight[typeId]];\n  }\n\n  /**\n        @notice Get current total (type-weighted) weight\n        @return Total weight\n    */\n  function getTotalWeight() external view virtual override returns (uint256) {\n    return pointsTotal[timeTotal];\n  }\n\n  /**\n        @notice Get sum of gauge weights per type\n        @param typeId Type id\n        @return Sum of gauge weights\n    */\n  function getWeightsSumPerType(int128 typeId) external view virtual override returns (uint256) {\n    return pointsSum[typeId][timeSum[typeId]].bias;\n  }\n\n  //-----------public----------\n\n  function pause() public onlyOwner {\n    _pause();\n  }\n\n  function unpause() public onlyOwner {\n    _unpause();\n  }\n\n  function initialize(address votingEscrow_, address p12CoinFactory_) public initializer {\n    require(votingEscrow_ != address(0) && p12CoinFactory_ != address(0), 'GC: address can not 0');\n    votingEscrow = IVotingEscrow(votingEscrow_);\n    p12CoinFactory = p12CoinFactory_;\n\n    __Pausable_init_unchained();\n    __Ownable_init_unchained();\n  }\n\n  //-----------internal----------\n  function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n  /**\n    @notice Fill historic type weights week-over-week for missed checkins\n        and return the type weight for the future week\n    @param gaugeType Gauge type id\n    @return Type weight\n  */\n  function _getTypeWeight(int128 gaugeType) internal virtual returns (uint256) {\n    uint256 t = timeTypeWeight[gaugeType];\n    if (t > 0) {\n      uint256 w = pointsTypeWeight[gaugeType][t];\n      for (uint256 i = 0; i < 500; i++) {\n        if (t > block.timestamp) {\n          break;\n        }\n        t += WEEK;\n        pointsTypeWeight[gaugeType][t] = w;\n        if (t > block.timestamp) {\n          timeTypeWeight[gaugeType] = t;\n        }\n      }\n      return w;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n    @notice Fill sum of gauge weights for the same type week-over-week for\n        missed checkins and return the sum for the future week\n    @param gaugeType Gauge type id\n    @return Sum of weights\n  */\n  function _getSum(int128 gaugeType) internal virtual returns (uint256) {\n    uint256 t = timeSum[gaugeType];\n    if (t > 0) {\n      Point memory pt = pointsSum[gaugeType][t];\n      for (uint256 i = 0; i < 500; i++) {\n        if (t > block.timestamp) {\n          break;\n        }\n        t += WEEK;\n        uint256 dBias = pt.slope * WEEK;\n        if (pt.bias > dBias) {\n          pt.bias -= dBias;\n          uint256 dSlope = changesSum[gaugeType][t];\n          pt.slope -= dSlope;\n        } else {\n          pt.bias = 0;\n          pt.slope = 0;\n        }\n        pointsSum[gaugeType][t] = pt;\n        if (t > block.timestamp) {\n          timeSum[gaugeType] = t;\n        }\n      }\n      return pt.bias;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n    @notice Fill historic total weights week-over-week for missed checkins\n      and return the total for the future week\n    @return Total weight\n  */\n  function _getTotal() internal virtual returns (uint256) {\n    uint256 t = timeTotal;\n    int128 _nGaugeTypes = nGaugeTypes;\n    if (t > block.timestamp) {\n      // If we have already checkpointed - still need to change the value\n      t -= WEEK;\n    }\n\n    uint256 pt = pointsTotal[t];\n    for (int128 gaugeType = 0; gaugeType < 100; gaugeType++) {\n      if (gaugeType == _nGaugeTypes) {\n        break;\n      }\n      _getSum(gaugeType);\n      _getTypeWeight(gaugeType);\n    }\n\n    for (uint256 i = 0; i < 500; i++) {\n      if (t > block.timestamp) {\n        break;\n      }\n\n      t += WEEK;\n      pt = 0;\n      // Scales as n_types * n_unchecked_weeks (hopefully 1 at most)\n      for (int128 gaugeType = 0; gaugeType < 100; gaugeType++) {\n        if (gaugeType == nGaugeTypes) {\n          break;\n        }\n        uint256 typeSum = pointsSum[gaugeType][t].bias;\n        uint256 typeWeight = pointsTypeWeight[gaugeType][t];\n        pt += typeSum * typeWeight;\n      }\n      pointsTotal[t] = pt;\n\n      if (t > block.timestamp) {\n        timeTotal = t;\n      }\n    }\n    return pt;\n  }\n\n  /**\n    @notice Fill historic gauge weights week-over-week for missed checkins\n        and return the total for the future week\n    @param gaugeAddr Address of the gauge\n    @return Gauge weight\n  */\n  function _getWeight(address gaugeAddr) internal virtual returns (uint256) {\n    uint256 t = timeWeight[gaugeAddr];\n    if (t > 0) {\n      Point memory pt = pointsWeight[gaugeAddr][t];\n      for (uint256 i = 0; i < 500; i++) {\n        if (t > block.timestamp) {\n          break;\n        }\n        t += WEEK;\n        uint256 dBias = pt.slope * WEEK;\n        if (pt.bias > dBias) {\n          pt.bias -= dBias;\n          uint256 dSlope = changesWeight[gaugeAddr][t];\n          pt.slope -= dSlope;\n        } else {\n          pt.bias = 0;\n          pt.slope = 0;\n        }\n        pointsWeight[gaugeAddr][t] = pt;\n        if (t > block.timestamp) {\n          timeWeight[gaugeAddr] = t;\n        }\n      }\n      return pt.bias;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n    @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n            (e.g. 1.0 == 1e18). Inflation which will be received by it is\n            inflation_rate * relative_weight / 1e18\n    @param addr Gauge address\n    @param time Relative weight at the specified timestamp in the past or present\n    @return Value of relative weight normalized to 1e18\n     */\n  function _gaugeRelativeWeight(address addr, uint256 time) internal view virtual returns (uint256) {\n    uint256 t = (time / WEEK) * WEEK;\n\n    uint256 totalWeight = pointsTotal[t];\n\n    if (totalWeight > 0) {\n      int128 gaugeType = gaugeTypes[addr] - 1;\n      uint256 typeWeight = pointsTypeWeight[gaugeType][t];\n      uint256 gaugeWeight = pointsWeight[addr][t].bias;\n      return (MULTIPLIER * typeWeight * gaugeWeight) / totalWeight;\n    } else {\n      return 0;\n    }\n  }\n\n  function _changeTypeWeight(int128 typeId, uint256 weight) internal virtual {\n    uint256 oldWeight = _getTypeWeight(typeId);\n    uint256 oldSum = _getSum(typeId);\n    uint256 totalWeight = _getTotal();\n    uint256 nextTime = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n    totalWeight = totalWeight + oldSum * weight - oldSum * oldWeight;\n    pointsTotal[nextTime] = totalWeight;\n    pointsTypeWeight[typeId][nextTime] = weight;\n    timeTotal = nextTime;\n    timeTypeWeight[typeId] = nextTime;\n\n    emit NewTypeWeight(typeId, nextTime, weight, totalWeight);\n  }\n\n  function _changeGaugeWeight(address addr, uint256 weight) internal virtual {\n    // Change gauge weight\n    // Only needed when testing in reality\n    int128 gaugeType = gaugeTypes[addr] - 1;\n    uint256 oldGaugeWeight = _getWeight(addr);\n    uint256 typeWeight = _getTypeWeight(gaugeType);\n    uint256 oldSum = _getSum(gaugeType);\n    uint256 totalWeight = _getTotal();\n    uint256 nextTime = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n    pointsWeight[addr][nextTime].bias = weight;\n    timeWeight[addr] = nextTime;\n\n    uint256 newSum = oldSum + weight - oldGaugeWeight;\n    pointsSum[gaugeType][nextTime].bias = newSum;\n    timeSum[gaugeType] = nextTime;\n\n    totalWeight = totalWeight + newSum * typeWeight - oldSum * typeWeight;\n    pointsTotal[nextTime] = totalWeight;\n    timeTotal = nextTime;\n\n    emit NewGaugeWeight(addr, block.timestamp, weight, totalWeight);\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/staking/interfaces/IGaugeController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\nimport '../../token/interfaces/IVotingEscrow.sol';\n\ninterface IGaugeController {\n  event CommitOwnership(address admin);\n\n  event ApplyOwnership(address admin);\n\n  event AddType(string name, int128 typeId);\n\n  event NewTypeWeight(int128 typeId, uint256 time, uint256 weight, uint256 totalWeight);\n\n  event NewGaugeWeight(address gaugeAddress, uint256 time, uint256 weight, uint256 totalWeight);\n\n  event VoteForGauge(uint256 time, address user, address gaugeAddress, uint256 weight);\n\n  event NewGauge(address addr, int128 gaugeType, uint256 weight);\n\n  event SetVotingEscrow(IVotingEscrow oldVotingEscrow, IVotingEscrow newVotingEscrow);\n\n  event SetP12Factory(address oldP12Factory, address newP12Factory);\n\n  function getGaugeTypes(address addr) external returns (int128);\n\n  function checkpoint() external;\n\n  function gaugeRelativeWeightWrite(address addr, uint256 time) external returns (uint256);\n\n  function changeTypeWeight(int128 typeId, uint256 weight) external;\n\n  function changeGaugeWeight(address addr, uint256 weight) external;\n\n  function voteForGaugeWeights(address gaugeAddr, uint256 userWeight) external;\n\n  function checkpointGauge(address addr) external;\n\n  function gaugeRelativeWeight(address lpToken, uint256 time) external returns (uint256);\n\n  function getGaugeWeight(address addr) external returns (uint256);\n\n  function getTypeWeight(int128 typeId) external returns (uint256);\n\n  function getTotalWeight() external returns (uint256);\n\n  function getWeightsSumPerType(int128 typeId) external returns (uint256);\n\n  function addGauge(\n    address addr,\n    int128 gaugeType,\n    uint256 weight\n  ) external;\n\n  function addType(string memory name, uint256 weight) external;\n\n  function setVotingEscrow(IVotingEscrow newVotingEscrow) external;\n\n  function setP12CoinFactory(address newP12Factory) external;\n}\n"
    },
    "contracts/staking/ControllerStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '../token/interfaces/IVotingEscrow.sol';\n\ncontract ControllerStorage {\n  IVotingEscrow public votingEscrow; // Voting escrow\n  address public p12CoinFactory;\n  // Gauge parameters\n  // All numbers are \"fixed point\" on the basis of 1e18\n  int128 public nGaugeTypes;\n  int128 public nGauges;\n  uint256 public timeTotal; // last scheduled time\n\n  uint256[45] private __gap;\n\n  mapping(int128 => string) public gaugeTypeNames;\n  // Needed for enumeration\n  mapping(int128 => address) public gauges;\n\n  // we increment values by 1 prior to storing them here so we can rely on a value\n  // of zero as meaning the gauge has not been set\n  mapping(address => int128) public gaugeTypes;\n\n  mapping(address => mapping(address => VotedSlope)) public voteUserSlopes; // user -> gauge_addr -> VotedSlope\n  mapping(address => uint256) public voteUserPower; // Total vote power used by user\n  mapping(address => mapping(address => uint256)) public lastUserVote; // Last user vote's timestamp for each gauge address\n\n  // Past and scheduled points for gauge weight, sum of weights per type, total weight\n  // Point is for bias+slope\n  // changes_* are for changes in slope\n  // time_* are for the last change timestamp\n  // timestamps are rounded to whole weeks\n\n  mapping(address => mapping(uint256 => Point)) public pointsWeight; // gauge_addr -> time -> Point\n  mapping(address => mapping(uint256 => uint256)) internal changesWeight; // gauge_addr -> time -> slope\n  mapping(address => uint256) public timeWeight; // gauge_addr -> last scheduled time (next week)\n\n  mapping(int128 => mapping(uint256 => Point)) public pointsSum; // type_id -> time -> Point\n  mapping(int128 => mapping(uint256 => uint256)) internal changesSum; // type_id -> time -> slope\n  mapping(int128 => uint256) public timeSum; // type_id -> last scheduled time (next week)\n\n  mapping(uint256 => uint256) public pointsTotal; // time -> total weight\n\n  mapping(int128 => mapping(uint256 => uint256)) public pointsTypeWeight; // type_id -> time -> type weight\n  mapping(int128 => uint256) public timeTypeWeight; // type_id -> last scheduled time (next week)\n\n  struct Point {\n    uint256 bias;\n    uint256 slope;\n  }\n\n  struct VotedSlope {\n    uint256 slope;\n    uint256 power;\n    uint256 end;\n  }\n\n  struct TmpBiasAndSlope {\n    uint256 oldWeightBias;\n    uint256 oldWeightSlope;\n    uint256 oldSumBias;\n    uint256 oldSumSlope;\n  }\n\n  struct TmpBias {\n    uint256 oldBias;\n    uint256 newBias;\n  }\n}\n"
    },
    "contracts/access/SafeOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// Refer to https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringOwnable.sol and https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/access/OwnableUpgradeable.sol\n\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\n\ncontract SafeOwnableUpgradeable is Initializable, ContextUpgradeable {\n  address private _owner;\n  address private _pendingOwner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  function __Ownable_init() internal onlyInitializing {\n    __Ownable_init_unchained();\n  }\n\n  function __Ownable_init_unchained() internal onlyInitializing {\n    _transferOwnership(_msgSender());\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Return the address of the pending owner\n   */\n  function pendingOwner() public view virtual returns (address) {\n    return _pendingOwner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(owner() == _msgSender(), 'SafeOwnable: caller not owner');\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    _transferOwnership(address(0));\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   * Note If direct is false, it will set an pending owner and the OwnerShipTransferring\n   * only happens when the pending owner claim the ownership\n   */\n  function transferOwnership(address newOwner, bool direct) public virtual onlyOwner {\n    require(newOwner != address(0), 'SafeOwnable: new owner is 0');\n    if (direct) {\n      _transferOwnership(newOwner);\n    } else {\n      _transferPendingOwnership(newOwner);\n    }\n  }\n\n  /**\n   * @dev pending owner call this function to claim ownership\n   */\n  function claimOwnership() public {\n    require(msg.sender == _pendingOwner, 'SafeOwnable: caller != pending');\n\n    _claimOwnership();\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Internal function without access restriction.\n   */\n  function _transferOwnership(address newOwner) internal virtual {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n\n  /**\n   * @dev set the pending owner address\n   * Internal function without access restriction.\n   */\n  function _transferPendingOwnership(address newOwner) internal virtual {\n    _pendingOwner = newOwner;\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Internal function without access restriction.\n   */\n  function _claimOwnership() internal virtual {\n    address oldOwner = _owner;\n    emit OwnershipTransferred(oldOwner, _pendingOwner);\n\n    _owner = _pendingOwner;\n    _pendingOwner = address(0);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/staking/P12MineUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport '@openzeppelin/contracts/utils/math/Math.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '../access/SafeOwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport { IP12RewardVault, P12RewardVault } from './P12RewardVault.sol';\nimport './interfaces/IGaugeController.sol';\nimport './interfaces/IP12MineUpgradeable.sol';\nimport './P12MineStorage.sol';\nimport '../access/SafeOwnableUpgradeable.sol';\nimport '../token/interfaces/IP12Token.sol';\n\ncontract P12MineUpgradeable is\n  P12MineStorage,\n  IP12MineUpgradeable,\n  UUPSUpgradeable,\n  SafeOwnableUpgradeable,\n  ReentrancyGuardUpgradeable,\n  PausableUpgradeable\n{\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using Math for uint256;\n\n  uint256 public constant ONE = 10**18;\n  uint256 public constant WEEK = 7 * 86400;\n\n  // ============ External ============\n\n  /**\n  @notice set new p12CoinFactory\n  @param newP12CoinFactory address of p12CoinFactory\n   */\n  function setP12CoinFactory(address newP12CoinFactory) external virtual override onlyOwner {\n    address oldP12CoinFactory = p12CoinFactory;\n    require(newP12CoinFactory != address(0), 'P12Mine: p12CoinFactory cannot be 0');\n    p12CoinFactory = newP12CoinFactory;\n    emit SetP12Factory(oldP12CoinFactory, newP12CoinFactory);\n  }\n\n  /**\n  @notice set new gaugeController\n  @param newGaugeController address of gaugeController\n   */\n  function setGaugeController(IGaugeController newGaugeController) external virtual override onlyOwner {\n    IGaugeController oldGaugeController = gaugeController;\n    require(address(newGaugeController) != address(0), 'P12Mine: gc cannot be 0');\n    gaugeController = newGaugeController;\n    emit SetGaugeController(oldGaugeController, newGaugeController);\n  }\n\n  /**\n    @notice Get pool len\n   */\n  function poolLength() external view virtual override returns (uint256) {\n    return poolInfos.length;\n  }\n\n  /**\n​    @notice withdraw token Emergency\n  */\n  function withdrawEmergency() external virtual override onlyOwner onlyEmergency {\n    p12RewardVault.withdrawEmergency(msg.sender);\n  }\n\n  /**\n    @notice update checkpoint for pool\n    @param lpToken Address of lpToken\n  */\n  function checkpoint(address lpToken) external {\n    uint256 pid = getPid(lpToken);\n    _checkpoint(pid);\n  }\n\n  // ============ Public ============\n\n  function pause() public onlyOwner {\n    _pause();\n  }\n\n  function unpause() public onlyOwner {\n    _unpause();\n  }\n\n  /**\n    @notice Contract initialization\n    @param p12Token_ Address of p12Token\n    @param p12CoinFactory_ Address of p12CoinFactory\n    @param gaugeController_ address of gaugeController\n    @param delayK_ delayK_ is a coefficient\n    @param delayB_ delayB_ is a coefficient\n   */\n  function initialize(\n    address p12Token_,\n    address p12CoinFactory_,\n    IGaugeController gaugeController_,\n    uint256 delayK_,\n    uint256 delayB_,\n    uint256 rate_\n  ) public initializer {\n    require(p12Token_ != address(0), 'P12Mine: p12Token cannot be 0');\n    require(p12CoinFactory_ != address(0), 'P12Mine: p12CoinFactory cannot be 0');\n\n    p12Token = p12Token_;\n    p12CoinFactory = p12CoinFactory_;\n    gaugeController = IGaugeController(gaugeController_);\n    p12RewardVault = IP12RewardVault(new P12RewardVault(p12Token_));\n    delayK = delayK_;\n    delayB = delayB_;\n    rate = rate_;\n\n    __ReentrancyGuard_init_unchained();\n    __Pausable_init_unchained();\n    __Ownable_init_unchained();\n  }\n\n  /**\n    @notice get withdraw unlockTimestamp\n    @param lpToken Address of lpToken\n    @param amount Number of lpToken\n   */\n  function getWithdrawUnlockTimestamp(address lpToken, uint256 amount) public view virtual override returns (uint256) {\n    uint256 pid = getPid(lpToken);\n    PoolInfo memory pool = poolInfos[pid];\n    uint256 time;\n    uint256 currentTimestamp = block.timestamp;\n    bytes32 _preWithdrawId = preWithdrawIds[lpToken];\n    uint256 lastUnlockTimestamp = withdrawInfos[lpToken][_preWithdrawId].unlockTimestamp;\n\n    time = currentTimestamp >= lastUnlockTimestamp ? currentTimestamp : lastUnlockTimestamp;\n    uint256 delay = (amount * delayK) / IERC20Upgradeable(pool.lpToken).totalSupply() + delayB;\n    uint256 unlockTimestamp = delay + time;\n    return unlockTimestamp;\n  }\n\n  /**\n    @notice Get pool id\n    @param lpToken Address of lpToken\n   */\n  function getPid(address lpToken) public view virtual override lpTokenExist(lpToken) returns (uint256) {\n    return lpTokenRegistry[lpToken] - 1;\n  }\n\n  /**\n    @notice Get user lpToken balance\n    @param lpToken Address of lpToken\n    @param user LpToken holder\n    @return Get lpToken balance \n   */\n  function getUserLpBalance(address lpToken, address user) public view virtual override returns (uint256) {\n    uint256 pid = getPid(lpToken);\n    return userInfo[pid][user].amount;\n  }\n\n  /**\n    @notice This method is only used when creating game coin in p12CoinFactory\n    @param lpToken Address of lpToken\n    @param gameCoinCreator user of game coin creator\n   */\n  function addLpTokenInfoForGameCreator(\n    address lpToken,\n    uint256 amount,\n    address gameCoinCreator\n  ) public virtual override whenNotPaused onlyP12Factory {\n    createPool(lpToken);\n    uint256 pid = getPid(lpToken);\n    uint256 totalLpStaked = IERC20Upgradeable(lpToken).balanceOf(address(this));\n    PoolInfo storage pool = poolInfos[pid];\n    UserInfo storage user = userInfo[pid][gameCoinCreator];\n    require(amount <= totalLpStaked - pool.amount && amount > 0, 'P12Mine: amount not met');\n    pool.period += 1;\n    periodTimestamp[pool.lpToken][pool.period] = block.timestamp;\n    user.amount += amount;\n    pool.amount += amount;\n    user.rewardDebt = (user.amount * pool.accP12PerShare) / ONE;\n    emit Deposit(gameCoinCreator, pid, amount, user.amount, pool.amount);\n  }\n\n  // ============ Ownable ============\n\n  /**\n    @notice set the isEmergency to true\n  */\n\n  function emergency() public virtual override onlyOwner {\n    require(!isEmergency, 'P12Mine: already exists');\n    isEmergency = true;\n    uint256 delayTime = 86400;\n    emergencyUnlockTime = block.timestamp + delayTime;\n    emit Emergency(msg.sender, emergencyUnlockTime);\n  }\n\n  /**\n    @notice Create a new pool\n    @param lpToken Address of lpToken\n   */\n  function createPool(address lpToken) public virtual override lpTokenNotExist(lpToken) whenNotPaused onlyP12FactoryOrOwner {\n    poolInfos.push(PoolInfo({ lpToken: lpToken, accP12PerShare: 0, amount: 0, period: 0 }));\n    periodTimestamp[lpToken][0] = block.timestamp;\n    lpTokenRegistry[lpToken] = poolInfos.length;\n  }\n\n  /**\n    @notice Set delayK value \n    @param newDelayK Is a coefficient\n    @return Get bool result \n   */\n  function setDelayK(uint256 newDelayK) public virtual override onlyOwner returns (bool) {\n    uint256 oldDelayK = delayK;\n    delayK = newDelayK;\n    emit SetDelayK(oldDelayK, delayK);\n    return true;\n  }\n\n  /**\n    @notice Set delayB value \n    @param newDelayB Is a coefficient\n    @return Get bool result \n   */\n  function setDelayB(uint256 newDelayB) public virtual override onlyOwner returns (bool) {\n    uint256 oldDelayB = delayB;\n    delayB = newDelayB;\n    emit SetDelayB(oldDelayB, delayB);\n    return true;\n  }\n\n  /**\n    @notice set new rate\n    @param newRate is p12 token inflation rate \n   */\n  function setRate(uint256 newRate) public virtual override onlyOwner returns (bool) {\n    uint256 oldRate = rate;\n    rate = newRate;\n    checkpointAll();\n    emit SetRate(oldRate, newRate);\n    return true;\n  }\n\n  /**\n    @notice update checkpoint for all pool\n   */\n  function checkpointAll() public virtual override {\n    uint256 length = poolInfos.length;\n    for (uint256 pid = 0; pid < length; pid++) {\n      _checkpoint(pid);\n    }\n  }\n\n  // ============ Deposit & Withdraw & Claim & ============\n  // Deposit & withdraw will also trigger claim\n\n  /**\n    @notice Deposit lpToken\n    @param lpToken Address of lpToken\n    @param amount Number of lpToken\n   */\n  function deposit(address lpToken, uint256 amount) public virtual override whenNotPaused nonReentrant {\n    uint256 pid = getPid(lpToken);\n    PoolInfo storage pool = poolInfos[pid];\n    UserInfo storage user = userInfo[pid][msg.sender];\n\n    _checkpoint(pid);\n    if (user.amount > 0) {\n      uint256 pending = (user.amount * pool.accP12PerShare) / ONE - user.rewardDebt;\n      _safeP12Transfer(msg.sender, pending);\n    }\n    require(amount != 0, 'P12Mine: need amount > 0');\n    user.amount += amount;\n    pool.amount += amount;\n    IERC20Upgradeable(pool.lpToken).safeTransferFrom(msg.sender, address(this), amount);\n    user.rewardDebt = (user.amount * pool.accP12PerShare) / ONE;\n    emit Deposit(msg.sender, pid, amount, user.amount, pool.amount);\n  }\n\n  /**\n  @notice Withdraw lpToken delay\n  @param lpToken Address of lpToken\n  @param amount Number of lpToken\n  */\n  function queueWithdraw(address lpToken, uint256 amount) public virtual override whenNotPaused nonReentrant {\n    uint256 pid = getPid(lpToken);\n    PoolInfo storage pool = poolInfos[pid];\n    UserInfo storage user = userInfo[pid][msg.sender];\n    require(user.amount >= amount, 'P12Mine: withdraw too much');\n    _checkpoint(pid);\n    if (user.amount > 0) {\n      uint256 pending = (user.amount * pool.accP12PerShare) / ONE - user.rewardDebt;\n      _safeP12Transfer(msg.sender, pending);\n    }\n    uint256 unlockTimestamp = getWithdrawUnlockTimestamp(lpToken, amount);\n    bytes32 newWithdrawId = _createWithdrawId(lpToken, amount, msg.sender);\n    withdrawInfos[lpToken][newWithdrawId] = WithdrawInfo(msg.sender, amount, unlockTimestamp, false);\n    user.rewardDebt = (user.amount * pool.accP12PerShare) / ONE;\n    emit QueueWithdraw(msg.sender, pid, amount, newWithdrawId, unlockTimestamp);\n  }\n\n  /**\n    @notice Get pending rewards\n    @param lpToken Address of lpToken\n   */\n  function claim(address lpToken) public virtual override nonReentrant whenNotPaused returns (uint256) {\n    uint256 pid = getPid(lpToken);\n    require(userInfo[pid][msg.sender].amount > 0, 'P12Mine: no staked token');\n    PoolInfo storage pool = poolInfos[pid];\n    UserInfo storage user = userInfo[pid][msg.sender];\n    _checkpoint(pid);\n    uint256 pending = (user.amount * pool.accP12PerShare) / ONE - user.rewardDebt;\n    user.rewardDebt = (user.amount * pool.accP12PerShare) / ONE;\n    _safeP12Transfer(msg.sender, pending);\n    return pending;\n  }\n\n  /**\n    @notice Get all pending rewards\n   */\n  function claimAll() public virtual override nonReentrant whenNotPaused returns (uint256) {\n    uint256 length = poolInfos.length;\n    uint256 pending = 0;\n    for (uint256 pid = 0; pid < length; pid++) {\n      if (userInfo[pid][msg.sender].amount == 0) {\n        continue; // save gas\n      }\n      PoolInfo storage pool = poolInfos[pid];\n      UserInfo storage user = userInfo[pid][msg.sender];\n      _checkpoint(pid);\n      pending += (user.amount * pool.accP12PerShare) / ONE - user.rewardDebt;\n      user.rewardDebt = (user.amount * pool.accP12PerShare) / ONE;\n    }\n    _safeP12Transfer(msg.sender, pending);\n    return pending;\n  }\n\n  /**\n    @notice Withdraw lpToken\n    @param lpToken Address of lpToken\n    @param id Withdraw id \n   */\n  function executeWithdraw(address lpToken, bytes32 id) public virtual override nonReentrant whenNotPaused {\n    uint256 pid = getPid(lpToken);\n    address _who = withdrawInfos[lpToken][id].who;\n    require(msg.sender == _who, 'P12Mine: caller not token owner');\n    PoolInfo storage pool = poolInfos[pid];\n    UserInfo storage user = userInfo[pid][_who];\n    require(withdrawInfos[lpToken][id].amount <= user.amount, 'P12Mine: withdraw too much');\n    require(block.timestamp >= withdrawInfos[lpToken][id].unlockTimestamp, 'P12Mine: unlock time not reached');\n    require(!withdrawInfos[lpToken][id].executed, 'P12Mine: already withdrawn');\n    withdrawInfos[lpToken][id].executed = true;\n    _checkpoint(pid);\n    uint256 pending = (user.amount * pool.accP12PerShare) / ONE - user.rewardDebt;\n    _safeP12Transfer(_who, pending);\n    uint256 amount = withdrawInfos[lpToken][id].amount;\n    user.amount -= amount;\n    pool.amount -= amount;\n    user.rewardDebt = (user.amount * pool.accP12PerShare) / ONE;\n    IERC20Upgradeable(pool.lpToken).safeTransfer(address(_who), amount);\n    emit ExecuteWithdraw(_who, pid, id, amount, user.amount, pool.amount);\n  }\n\n  /**\n​    @notice withdraw lpToken Emergency\n  */\n\n  function withdrawAllLpTokenEmergency() public virtual override {\n    uint256 length = poolInfos.length;\n\n    for (uint256 pid = 0; pid < length; pid++) {\n      if (userInfo[pid][msg.sender].amount == 0) {\n        continue; // save gas\n      }\n      PoolInfo memory pool = poolInfos[pid];\n      withdrawLpTokenEmergency(pool.lpToken);\n    }\n  }\n\n  /**\n​    @notice withdraw all lpToken Emergency\n    @param lpToken address of lpToken\n  */\n  function withdrawLpTokenEmergency(address lpToken) public virtual override nonReentrant onlyEmergency {\n    uint256 pid = getPid(lpToken);\n    PoolInfo storage pool = poolInfos[pid];\n    UserInfo storage user = userInfo[pid][msg.sender];\n    require(user.amount > 0, 'P12Mine: without any lpToken');\n    uint256 amount = user.amount;\n    user.amount = 0;\n    user.rewardDebt = 0;\n    IERC20Upgradeable(pool.lpToken).safeTransfer(address(msg.sender), amount);\n    emit WithdrawLpTokenEmergency(lpToken, amount);\n  }\n\n  // ============ Internal ============\n\n  function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n  /**\n    @notice Transfer p12 to user\n    @param  to The address of receiver\n    @param amount Number of p12\n   */\n  function _safeP12Transfer(address to, uint256 amount) internal virtual {\n    p12RewardVault.reward(to, amount);\n    realizedReward[to] = realizedReward[to] + amount;\n    emit Claim(to, amount);\n  }\n\n  /**\n    @notice Create withdraw id\n    @param lpToken Address of lpToken\n    @param amount Number of lpToken\n    @param to Address of receiver\n    @return hash Get a withdraw Id\n   */\n  function _createWithdrawId(\n    address lpToken,\n    uint256 amount,\n    address to\n  ) internal virtual returns (bytes32 hash) {\n    bytes32 preWithdrawId = preWithdrawIds[lpToken];\n    bytes32 withdrawId = keccak256(abi.encode(lpToken, amount, to, preWithdrawId));\n    preWithdrawIds[lpToken] = withdrawId;\n    return withdrawId;\n  }\n\n  // ============ checkpoint ============\n  /**\n      @notice update checkpoint for pool\n      @param pid Pool Id\n  */\n  function _checkpoint(uint256 pid) internal virtual whenNotPaused {\n    PoolInfo storage pool = poolInfos[pid];\n    uint256 _accP12PerShare = pool.accP12PerShare;\n    uint256 _periodTime = periodTimestamp[pool.lpToken][pool.period];\n    gaugeController.checkpointGauge(address(pool.lpToken));\n    require(block.timestamp > _periodTime, 'P12Mine: not time to check');\n\n    if (pool.amount == 0) {\n      pool.period += 1;\n      periodTimestamp[pool.lpToken][pool.period] = block.timestamp;\n      return;\n    }\n    uint256 prevWeekTime = _periodTime;\n    uint256 weekTime = Math.min(((_periodTime + WEEK) / WEEK) * WEEK, block.timestamp);\n    for (uint256 i = 0; i < 500; i++) {\n      uint256 dt = weekTime - prevWeekTime;\n      uint256 w = gaugeController.gaugeRelativeWeight(pool.lpToken, (prevWeekTime / WEEK) * WEEK);\n      _accP12PerShare += (rate * w * dt) / pool.amount;\n      if (weekTime == block.timestamp) {\n        break;\n      }\n      prevWeekTime = weekTime;\n      weekTime = Math.min(weekTime + WEEK, block.timestamp);\n    }\n    pool.accP12PerShare = _accP12PerShare;\n    pool.period += 1;\n    periodTimestamp[pool.lpToken][pool.period] = block.timestamp;\n    emit Checkpoint(pool.lpToken, pool.amount, pool.accP12PerShare);\n  }\n\n  // ============ Modifiers ============\n\n  // check if lpToken exists\n  modifier lpTokenExist(address lpToken) {\n    require(lpTokenRegistry[lpToken] > 0, 'P12Mine: LP Token Not Exist');\n    _;\n  }\n  // check if lpToken exists\n  modifier lpTokenNotExist(address lpToken) {\n    require(lpTokenRegistry[lpToken] == 0, 'P12Mine: LP Token Already Exist');\n    _;\n  }\n\n  // check the caller\n  modifier onlyP12FactoryOrOwner() {\n    require(msg.sender == address(p12CoinFactory) || msg.sender == owner(), 'P12Mine: not p12factory or owner');\n    _;\n  }\n\n  // check the caller\n  modifier onlyP12Factory() {\n    require(msg.sender == address(p12CoinFactory), 'P12Mine: caller not p12factory');\n    _;\n  }\n\n  // check Emergency\n  modifier onlyEmergency() {\n    require(isEmergency, 'P12Mine: no emergency now');\n    require(block.timestamp >= emergencyUnlockTime, 'P12Mine: not unlocked yet');\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/staking/P12RewardVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\npragma experimental ABIEncoderV2;\n\nimport '../access/SafeOwnable.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport './interfaces/IP12RewardVault.sol';\nimport '../token/interfaces/IP12Token.sol';\n\ncontract P12RewardVault is SafeOwnable, IP12RewardVault {\n  using SafeERC20 for IERC20;\n\n  address public p12Token;\n\n  constructor(address p12Token_) {\n    require(p12Token_ != address(0), 'P12RV: address cannot be 0');\n    p12Token = p12Token_;\n  }\n\n  /**\n    @notice Send reward to user\n    @param to The address of awards \n    @param amount number of awards \n   */\n  function reward(address to, uint256 amount) external virtual override onlyOwner {\n    IERC20(p12Token).safeTransfer(to, amount);\n  }\n\n  /**\n    @notice withdraw token Emergency\n   */\n  function withdrawEmergency(address to) external virtual override onlyOwner {\n    require(to != address(0), 'P12RV: address cannot be 0');\n    IERC20(p12Token).safeTransfer(to, IERC20(p12Token).balanceOf(address(this)));\n    emit WithdrawEmergency(p12Token, IERC20(p12Token).balanceOf(address(this)));\n  }\n}\n"
    },
    "contracts/staking/interfaces/IP12MineUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\nimport '../../token/interfaces/IVotingEscrow.sol';\nimport './IGaugeController.sol';\n\ninterface IP12MineUpgradeable {\n  event Deposit(address indexed user, uint256 indexed pid, uint256 amount, uint256 userAmount, uint256 poolAmount); // deposit lpToken log\n  event ExecuteWithdraw(\n    address indexed user,\n    uint256 indexed pid,\n    bytes32 indexed withdrawId,\n    uint256 amount,\n    uint256 userAmount,\n    uint256 poolAmount\n  ); // withdraw lpToken log\n  event QueueWithdraw(\n    address indexed user,\n    uint256 pid,\n    uint256 indexed amount,\n    bytes32 indexed newWithdrawId,\n    uint256 unlockTimestamp\n  ); // delayed unStaking mining log\n  event Claim(address indexed user, uint256 amount); // get rewards\n  event SetDelayB(uint256 oldDelayB, uint256 newDelayB); // change delayB log\n  event SetDelayK(uint256 oldDelayK, uint256 newDelayK); // change delayK log\n  event SetRate(uint256 oldRate, uint256 newRate); // set new rate\n  event SetP12Factory(address oldP12Factory, address newP12Factory);\n  event SetGaugeController(IGaugeController oldGaugeController, IGaugeController newGaugeController);\n  event WithdrawLpTokenEmergency(address lpToken, uint256 amount);\n\n  event Emergency(address executor, uint256 emergencyUnlockTime);\n  event Checkpoint(address indexed lpToken, uint256 indexed poolAmount, uint256 accP12PerShare);\n\n  function poolLength() external returns (uint256);\n\n  function getPid(address lpToken) external returns (uint256);\n\n  function getUserLpBalance(address lpToken, address user) external returns (uint256);\n\n  function checkpointAll() external;\n\n  function getWithdrawUnlockTimestamp(address lpToken, uint256 amount) external returns (uint256);\n\n  function withdrawEmergency() external;\n\n  function withdrawLpTokenEmergency(address lpToken) external;\n\n  function withdrawAllLpTokenEmergency() external;\n\n  function emergency() external;\n\n  function createPool(address lpToken) external; // new pool\n\n  function setDelayK(uint256 delayK) external returns (bool);\n\n  function setDelayB(uint256 delayB) external returns (bool);\n\n  function deposit(address lpToken, uint256 amount) external; // deposit lpToken\n\n  function setRate(uint256 newRate) external returns (bool);\n\n  function setP12CoinFactory(address newP12Factory) external;\n\n  function setGaugeController(IGaugeController newGaugeController) external;\n\n  function executeWithdraw(address lpToken, bytes32 id) external; // withdraw lpToken\n\n  function queueWithdraw(address lpToken, uint256 amount) external; // delayed unStaking mining\n\n  function addLpTokenInfoForGameCreator(\n    address lpToken,\n    uint256 amount,\n    address gameCoinCreator\n  ) external; // add lpToken info for gameCoin creator when first time\n\n  function claim(address lpToken) external returns (uint256); // get pending rewards\n\n  function claimAll() external returns (uint256); // get all pending rewards\n\n  function checkpoint(address lpToken) external;\n}\n"
    },
    "contracts/staking/P12MineStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\nimport './interfaces/IGaugeController.sol';\nimport './interfaces/IP12RewardVault.sol';\nimport '../token/interfaces/IP12Token.sol';\n\ncontract P12MineStorage {\n  address public p12CoinFactory;\n  address public p12Token;\n  IGaugeController public gaugeController;\n  IP12RewardVault public p12RewardVault;\n\n  uint256 public delayK;\n  uint256 public delayB;\n  uint256 public rate;\n\n  // Info of each pool.\n  PoolInfo[] public poolInfos;\n\n  bool public isEmergency;\n  uint256 public emergencyUnlockTime;\n\n  uint256[40] private __gap;\n\n  mapping(address => uint256) public lpTokenRegistry;\n  // Info of each user that stakes LP tokens.\n  mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n  mapping(address => uint256) public realizedReward;\n  // address=>period=>timestamp\n  mapping(address => mapping(uint256 => uint256)) public periodTimestamp;\n\n  // lpToken => id\n  mapping(address => bytes32) public preWithdrawIds;\n  // lpToken => id=> WithdrawInfo\n  mapping(address => mapping(bytes32 => WithdrawInfo)) public withdrawInfos;\n\n  // Info of each user.\n  struct UserInfo {\n    uint256 amount; // How many LP tokens the user has provided.\n    uint256 rewardDebt; // Reward debt. See explanation below.\n    //\n    // We do some fancy math here. Basically, any point in time, the amount of P12s\n    // entitled to a user but is pending to be distributed is:\n    //\n    //   pending reward = (Amount * pool.accP12PerShare) - user.rewardDebt\n    //\n    // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n    //   1. The pool's `accP12PerShare` (and `lastRewardBlock`) gets updated.\n    //   2. User receives the pending reward sent to his/her address.\n    //   3. User's `amount` gets updated.\n    //   4. User's `rewardDebt` gets updated.\n  }\n\n  // Info of each pool.\n  struct PoolInfo {\n    address lpToken; // Address of LP token contract.\n    uint256 accP12PerShare; // Accumulated P12s per share, times 1e18. See below.\n    uint256 amount; // how many lpToken in this pool\n    uint256 period;\n  }\n  // withdraw info\n  struct WithdrawInfo {\n    address who;\n    uint256 amount;\n    uint256 unlockTimestamp;\n    bool executed;\n  }\n}\n"
    },
    "contracts/token/interfaces/IP12Token.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\ninterface IP12Token {\n  function mint(address recipient, uint256 amount) external;\n}\n"
    },
    "contracts/staking/interfaces/IP12RewardVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\ninterface IP12RewardVault {\n  function reward(address to, uint256 amount) external; // send reward\n\n  function withdrawEmergency(address to) external;\n\n  event WithdrawEmergency(address p12Token, uint256 amount);\n}\n"
    },
    "contracts/tests/P12MineUpgradeableAlter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\nimport '../staking/P12MineUpgradeable.sol';\n\ncontract P12MineUpgradeableAlter is P12MineUpgradeable {}\n"
    },
    "contracts/token/P12Token.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '../access/SafeOwnable.sol';\n\nimport './interfaces/IP12Token.sol';\n\n// temporary contract, not corresponding to real token model\n\ncontract P12Token is IP12Token, ERC20, SafeOwnable {\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 totalSupply\n  ) ERC20(name, symbol) {\n    _mint(msg.sender, totalSupply);\n  }\n\n  function mint(address recipient, uint256 amount) public override onlyOwner {\n    _mint(recipient, amount);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/tests/GameCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '../access/SafeOwnable.sol';\n\npragma solidity 0.8.15;\n\ncontract TestGameCoin is ERC20, SafeOwnable {\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 totalSupply\n  ) ERC20(name, symbol) {\n    _mint(msg.sender, totalSupply);\n  }\n\n  function mint(address account, uint256 amount) public onlyOwner returns (bool) {\n    _mint(account, amount);\n    return true;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/secretShop/ERC721Delegate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/access/AccessControl.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport './MarketConsts.sol';\nimport './interfaces/IDelegate.sol';\n\ncontract ERC721Delegate is IDelegate, AccessControl, IERC721Receiver, ReentrancyGuard, Pausable {\n  bytes32 public constant DELEGATION_CALLER = keccak256('DELEGATION_CALLER');\n  bytes32 public constant PAUSABLE_CALLER = keccak256('PAUSABLE_CALLER');\n\n  /**\n   * @dev single item data\n   */\n  struct Pair {\n    uint256 salt;\n    IERC721 token;\n    uint256 tokenId;\n  }\n\n  constructor() {\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n  }\n\n  /**\n   * @return delegateType the delegate's type\n   */\n  function delegateType() external pure override returns (uint256) {\n    return uint256(Market.DelegationType.ERC721);\n  }\n\n  /**\n   * @dev Received function\n   */\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes calldata\n  ) external pure override returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n\n  function pause() public onlyRole(PAUSABLE_CALLER) {\n    _pause();\n  }\n\n  function unpause() public onlyRole(PAUSABLE_CALLER) {\n    _unpause();\n  }\n\n  /**\n   * @dev decode data to the array of Pair\n   */\n  function decode(bytes calldata data) public pure returns (Pair[] memory) {\n    return abi.decode(data, (Pair[]));\n  }\n\n  /**\n   * @dev run the sell to transfer item\n   * @param seller address which sell the item\n   * @param buyer address which buy the item\n   * @param data the item's data, which will be decode as a array of Pair\n   */\n  function executeSell(\n    address seller,\n    address buyer,\n    bytes calldata data\n  ) public override nonReentrant onlyRole(DELEGATION_CALLER) whenNotPaused returns (bool) {\n    Pair[] memory pairs = decode(data);\n    for (uint256 i = 0; i < pairs.length; i++) {\n      Pair memory p = pairs[i];\n      p.token.safeTransferFrom(seller, buyer, p.tokenId);\n    }\n    return true;\n  }\n}\n"
    },
    "contracts/secretShop/MarketConsts.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\nimport './interfaces/IDelegate.sol';\nimport './interfaces/IWETHUpgradable.sol';\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\n\nlibrary Market {\n  uint256 public constant INTENT_SELL = 1;\n  uint256 public constant INTENT_BUY = 2;\n\n  uint8 public constant SIGN_V1 = 1;\n\n  struct OrderItem {\n    uint256 price;\n    /** why bytes: because struct too complex will be omitted */\n    bytes data;\n  }\n\n  // An Order\n  struct Order {\n    /* salt, a random number */\n    uint256 salt;\n    /* address which create order */\n    address user;\n    /** ChainId explain which network */\n    uint256 network;\n    /** which intent, 1 for sell */\n    uint256 intent;\n    /** just 1 at v1 */\n    uint256 delegateType;\n    /** order end ddl */\n    uint256 deadline;\n    /**\n      address of the ERC20 coin to trade\n    */\n    IERC20Upgradeable currency;\n    /**\n      items in an Order\n    */\n    OrderItem[] items;\n    /**\n      signature for Order, eip 2098 would be better\n    */\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    /**\n      could be 1 now\n    */\n    uint8 signVersion;\n  }\n\n  struct Fee {\n    uint256 percentage;\n    address to;\n  }\n\n  struct SettleDetail {\n    // order operation type\n    Market.Op op;\n    //\n    uint256 orderIdx;\n    //\n    uint256 itemIdx;\n    //\n    uint256 price;\n    //\n    bytes32 itemHash;\n    // delegate which address to transfer token\n    IDelegate executionDelegate;\n    Fee[] fees;\n  }\n\n  /**\n   * @dev information from who send this tx\n   */\n  struct SettleShared {\n    uint256 salt;\n    uint256 deadline;\n    address user;\n    /**\n     * can one order fail\n     * if true, tx will revert if one order fail\n     * else, tx didn't fail if one\n     */\n    bool canFail;\n  }\n\n  struct RunInput {\n    // one Order match one SettleDetail\n    Order[] orders;\n    SettleDetail[] details;\n    SettleShared shared;\n  }\n\n  enum InvStatus {\n    NEW,\n    COMPLETE,\n    CANCELLED\n  }\n\n  /**\n    Operation\n  */\n  enum Op {\n    INVALID,\n    COMPLETE_SELL_OFFER,\n    COMPLETE_BUY_OFFER,\n    CANCEL_OFFER\n  }\n\n  enum DelegationType {\n    INVALID,\n    ERC1155,\n    ERC721\n  }\n}\n"
    },
    "contracts/secretShop/interfaces/IDelegate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\ninterface IDelegate {\n  function delegateType() external view returns (uint256);\n\n  function executeSell(\n    address seller,\n    address buyer,\n    bytes calldata data\n  ) external returns (bool);\n}\n"
    },
    "contracts/secretShop/interfaces/IWETHUpgradable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\n\ninterface IWETHUpgradable is IERC20Upgradeable {\n  function deposit() external payable;\n\n  function withdraw(uint256 wad) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/secretShop/SecretShopUpgradable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport './interfaces/IDelegate.sol';\nimport './interfaces/IWETHUpgradable.sol';\n\nimport './interfaces/ISecretShopUpgradable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport './SecretShopStorage.sol';\nimport '../access/SafeOwnableUpgradeable.sol';\n\ncontract SecretShopUpgradable is\n  SecretShopStorage,\n  ISecretShopUpgradable,\n  ReentrancyGuardUpgradeable,\n  SafeOwnableUpgradeable,\n  PausableUpgradeable,\n  UUPSUpgradeable\n{\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /** @dev precision of the parameters */\n  uint256 public constant RATE_BASE = 1e6;\n\n  /**\n   * @dev for contract to receive native token\n   */\n  receive() external payable {}\n\n  /**\n   * @dev run a single order\n   * @param order order by the maker\n   * @param shared some option of the taker\n   * @param detail detail by the taker\n   */\n  function runSingle(\n    Market.Order memory order,\n    Market.SettleShared memory shared,\n    Market.SettleDetail memory detail\n  ) external virtual override returns (uint256) {\n    require(msg.sender == address(this), 'SecretShop: unsafe call');\n\n    return _run(order, shared, detail);\n  }\n\n  function pause() public onlyOwner {\n    _pause();\n  }\n\n  function unpause() public onlyOwner {\n    _unpause();\n  }\n\n  /**\n   * @dev initialize\n   * @param feeCapPct_ max fee percentage\n   * @param weth_ address of wrapped eth\n   */\n  function initialize(uint256 feeCapPct_, address weth_) public initializer {\n    feeCapPct = feeCapPct_;\n    weth = IWETHUpgradable(weth_);\n    bytes32 eip712DomainTypeHash = keccak256(\n      'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n    );\n\n    // if changed, not compatible with old version\n    domainSeparator = keccak256(\n      abi.encode(\n        eip712DomainTypeHash,\n        keccak256(bytes('P12 SecretShop')),\n        keccak256(bytes('1.0.0')),\n        block.chainid,\n        address(this)\n      )\n    );\n\n    __ReentrancyGuard_init_unchained();\n    __Pausable_init_unchained();\n    __Ownable_init_unchained();\n  }\n\n  /**\n   * @param val new Fee Cap\n   */\n  function updateFeeCap(uint256 val) public virtual override onlyOwner {\n    feeCapPct = val;\n    emit EvFeeCapUpdate(val);\n  }\n\n  /**\n   * @dev update Delegates address\n   * @param toAdd the array of delegate address that want to add\n   * @param toRemove the array to delegate address that want to remove\n   */\n  function updateDelegates(address[] calldata toAdd, address[] calldata toRemove) public virtual override onlyOwner {\n    for (uint256 i = 0; i < toAdd.length; i++) {\n      delegates[toAdd[i]] = true;\n      emit EvDelegate(toAdd[i], false);\n    }\n    for (uint256 i = 0; i < toRemove.length; i++) {\n      delete delegates[toRemove[i]];\n      emit EvDelegate(toRemove[i], true);\n    }\n  }\n\n  /**\n   * @dev update Currencies address\n   * @param toAdd the array of currency address that want to add\n   * @param toRemove the array to currency address that want to remove\n   */\n  function updateCurrencies(IERC20Upgradeable[] memory toAdd, IERC20Upgradeable[] memory toRemove) public override onlyOwner {\n    for (uint256 i = 0; i < toAdd.length; i++) {\n      currencies[toAdd[i]] = true;\n      emit EvCurrency(toAdd[i], false);\n    }\n    for (uint256 i = 0; i < toRemove.length; i++) {\n      delete currencies[toRemove[i]];\n      emit EvCurrency(toRemove[i], true);\n    }\n  }\n\n  /**\n   * @dev Entry of a contract call\n   * @param input a struct that contains all data\n   */\n  function run(Market.RunInput memory input) public payable virtual override nonReentrant whenNotPaused {\n    require(input.shared.deadline > block.timestamp, 'SecretShop: deadline reached');\n    require(msg.sender == input.shared.user, 'SecretShop: sender not match');\n\n    uint256 amountEth = msg.value;\n\n    /**\n     * @dev Iterate over multiple orders and verify signatures\n     */\n    for (uint256 i = 0; i < input.orders.length; i++) {\n      _verifyOrderSignature(input.orders[i]);\n    }\n\n    /**\n     * @dev try to execute after verify\n     */\n    for (uint256 i = 0; i < input.details.length; i++) {\n      Market.SettleDetail memory detail = input.details[i];\n      Market.Order memory order = input.orders[detail.orderIdx];\n      if (input.shared.canFail) {\n        try ISecretShopUpgradable(address(this)).runSingle(order, input.shared, detail) returns (uint256 ethPayment) {\n          amountEth -= ethPayment;\n        } catch Error(string memory err) {\n          emit EvFailure(i, bytes(err));\n        } catch (bytes memory err) {\n          emit EvFailure(i, err);\n        }\n      } else {\n        amountEth -= _run(order, input.shared, detail);\n      }\n    }\n\n    // refund extra native token\n    require(payable(msg.sender).send(amountEth), 'SecretShop: refund token fail');\n  }\n\n  function _emitInventory(\n    bytes32 itemHash,\n    Market.Order memory order,\n    Market.OrderItem memory item,\n    Market.SettleShared memory shared,\n    Market.SettleDetail memory detail\n  ) internal virtual {\n    emit EvInventory(\n      itemHash,\n      order.user,\n      shared.user,\n      order.salt,\n      shared.salt,\n      order.intent,\n      order.delegateType,\n      order.deadline,\n      order.currency,\n      item,\n      detail\n    );\n  }\n\n  /**\n   * @dev internal function, real implementation\n   * @dev make single trade to be achieved\n   * @param order order by the maker\n   * @param shared some option of the taker\n   * @param detail detail by the taker\n   */\n  function _run(\n    Market.Order memory order,\n    Market.SettleShared memory shared,\n    Market.SettleDetail memory detail\n  ) internal virtual returns (uint256) {\n    uint256 nativeAmount = 0;\n\n    Market.OrderItem memory item = order.items[detail.itemIdx];\n    bytes32 itemHash = _hashItem(order, item);\n\n    {\n      require(itemHash == detail.itemHash, 'SecretShop: hash not match');\n      require(order.network == block.chainid, 'SecretShop: wrong network');\n      require(\n        address(detail.executionDelegate) != address(0) && delegates[address(detail.executionDelegate)],\n        'SecretShop: unknown delegate'\n      );\n      require(currencies[order.currency], 'SecretShop: wrong currency');\n    }\n\n    bytes memory data = item.data;\n\n    if (detail.op == Market.Op.COMPLETE_SELL_OFFER) {\n      /** @dev COMPLETE_SELL_OFFER */\n      require(inventoryStatus[itemHash] == Market.InvStatus.NEW, 'SecretShop: sold or canceled');\n      require(order.intent == Market.INTENT_SELL, 'SecretShop: intent != sell');\n      _assertDelegation(order, detail);\n      require(order.deadline > block.timestamp, 'SecretShop: deadline reached');\n      require(detail.price >= item.price, 'SecretShop: underpaid');\n\n      /**\n       * @dev transfer token from buyer address to this contract\n       */\n      nativeAmount = _takePayment(order.currency, shared.user, detail.price);\n      require(detail.executionDelegate.executeSell(order.user, shared.user, data), 'SecretShop: delegation error');\n\n      _distributeFeeAndProfit(itemHash, order.user, order.currency, detail, detail.price);\n      inventoryStatus[itemHash] = Market.InvStatus.COMPLETE;\n    } else if (detail.op == Market.Op.COMPLETE_BUY_OFFER) {\n      /** @dev COMPLETE_BUY_OFFER */\n      require(inventoryStatus[itemHash] == Market.InvStatus.NEW, 'SecretShop: sold or canceled');\n      require(order.intent == Market.INTENT_BUY, 'SecretShop: intent != sell');\n\n      _assertDelegation(order, detail);\n\n      require(order.deadline > block.timestamp, 'SecretShop: deadline reached');\n      require(detail.price >= item.price, 'SecretShop: underpaid');\n\n      /**\n       * @dev transfer token from buyer address to this contract\n       */\n      nativeAmount = _takePayment(order.currency, order.user, detail.price);\n      require(detail.executionDelegate.executeSell(shared.user, order.user, data), 'SecretShop: delegation error');\n\n      _distributeFeeAndProfit(itemHash, shared.user, order.currency, detail, detail.price);\n      inventoryStatus[itemHash] = Market.InvStatus.COMPLETE;\n    } else if (detail.op == Market.Op.CANCEL_OFFER) {\n      /** CANCEL_OFFER */\n      require(inventoryStatus[itemHash] == Market.InvStatus.NEW, 'SecretShop: unable to cancel');\n      require(order.user == msg.sender, 'SecretShop: no permit cancel');\n      require(order.deadline > block.timestamp, 'SecretShop: deadline reached');\n      inventoryStatus[itemHash] = Market.InvStatus.CANCELLED;\n      emit EvCancel(itemHash);\n    } else {\n      revert('SecretShop: unknown op');\n    }\n\n    _emitInventory(itemHash, order, item, shared, detail);\n    return nativeAmount;\n  }\n\n  /**\n   * @dev transfer some kind ERC20 to this contract\n   * @param currency currency's address\n   * @param from who pays\n   * @param amount how much pay\n   */\n  function _takePayment(\n    IERC20Upgradeable currency,\n    address from,\n    uint256 amount\n  ) internal virtual returns (uint256) {\n    if (amount > 0) {\n      if (_isNative(currency)) {\n        return amount;\n      } else {\n        currency.safeTransferFrom(from, address(this), amount);\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * @dev transfer some kind ERC20\n   * @param currency currency's address\n   * @param to who receive\n   * @param amount how much receive\n   */\n  function _transferTo(\n    IERC20Upgradeable currency,\n    address to,\n    uint256 amount\n  ) internal virtual {\n    if (amount > 0) {\n      if (_isNative(currency)) {\n        AddressUpgradeable.sendValue(payable(to), amount);\n      } else {\n        currency.safeTransfer(to, amount);\n      }\n    }\n  }\n\n  /**\n   * @dev distribute fees and give extra to seller\n   * @param itemHash the item's hash\n   * @param seller who sell the item\n   * @param currency currency's address\n   * @param sd detail by the taker\n   * @param price the item's price\n   */\n  function _distributeFeeAndProfit(\n    bytes32 itemHash,\n    address seller,\n    IERC20Upgradeable currency,\n    Market.SettleDetail memory sd,\n    uint256 price\n  ) internal virtual {\n    uint256 payment = price;\n    uint256 totalFeePct;\n\n    /**\n     * @dev distribute fees\n     */\n    for (uint256 i = 0; i < sd.fees.length; i++) {\n      Market.Fee memory fee = sd.fees[i];\n      totalFeePct += fee.percentage;\n      uint256 amount = (price * fee.percentage) / RATE_BASE;\n      payment -= amount;\n      _transferTo(currency, fee.to, amount);\n    }\n\n    require(feeCapPct >= totalFeePct, 'total fee cap exceeded');\n\n    /**\n     * @dev give extra to seller\n     */\n    _transferTo(currency, seller, payment);\n    emit EvProfit(itemHash, address(currency), seller, payment);\n  }\n\n  /** upgrade function */\n  function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n  /**\n   * @dev judge whether token is chain native token\n   * @param currency address of the currency, 0 for native token\n   * @return bool whether the token is a native token\n   */\n  function _isNative(IERC20Upgradeable currency) internal view virtual returns (bool) {\n    return address(currency) == address(0);\n  }\n\n  /**\n   * @dev verify whether the order data is real, necessary for security\n   * @param order order by the maker\n   */\n  function _verifyOrderSignature(Market.Order memory order) internal view virtual {\n    address orderSigner;\n\n    if (order.signVersion == Market.SIGN_V1) {\n      bytes32 dataHash = ECDSA.toTypedDataHash(domainSeparator, _hash(order));\n      orderSigner = ECDSA.recover(dataHash, order.v, order.r, order.s);\n    } else {\n      revert('SecretShop: wrong sig version');\n    }\n\n    require(orderSigner == order.user, 'SecretShop: sig not match');\n  }\n\n  /**\n   * @dev hash an item Data to calculate itemHash\n   * @param order order by the maker\n   * @param item which item to be hashed in the order\n   * @return hash the item's hash, which is unique\n   */\n  function _hashItem(Market.Order memory order, Market.OrderItem memory item) internal view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          order.salt,\n          order.user,\n          order.network,\n          order.intent,\n          order.delegateType,\n          order.deadline,\n          order.currency,\n          item\n        )\n      );\n  }\n\n  /**\n   * @dev judge delegate type\n   * @param order order by the maker\n   * @param detail settle detail by the taker\n   */\n  function _assertDelegation(Market.Order memory order, Market.SettleDetail memory detail) internal view virtual {\n    require(detail.executionDelegate.delegateType() == order.delegateType, 'SecretShop: delegation error');\n  }\n\n  /**\n   * @dev hash typed data of an Order\n   * @param order order by the maker\n   * @return hash typed data hash\n   */\n  function _hash(Market.Order memory order) private pure returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          keccak256(\n            'Order(uint256 salt,address user,uint256 network,uint256 intent,uint256 delegateType,uint256 deadline,address currency,uint256 length,OrderItem[] items)OrderItem(uint256 price,bytes data)'\n          ),\n          order.salt,\n          order.user,\n          order.network,\n          order.intent,\n          order.delegateType,\n          order.deadline,\n          order.currency,\n          order.items.length,\n          _hash(order.items)\n        )\n      );\n  }\n\n  /**\n   * @dev hash typed data of a array of orderItem\n   * @param orderItems[] the array of the orderItem\n   * @return hash typed data hash\n   */\n  function _hash(Market.OrderItem[] memory orderItems) private pure returns (bytes32) {\n    bytes memory h;\n    for (uint256 i = 0; i < orderItems.length; i++) {\n      h = abi.encodePacked(h, _hash(orderItems[i]));\n    }\n    return keccak256(h);\n  }\n\n  /**\n   * @dev hash typed data of an orderItem\n   * @param orderItem orderItem\n   * @return hash typed data hash\n   */\n\n  function _hash(Market.OrderItem memory orderItem) private pure returns (bytes32) {\n    return keccak256(abi.encode(keccak256('OrderItem(uint256 price,bytes data)'), orderItem.price, keccak256(orderItem.data)));\n  }\n}\n"
    },
    "contracts/secretShop/interfaces/ISecretShopUpgradable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\nimport '../MarketConsts.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\n\ninterface ISecretShopUpgradable {\n  /**\n   * @dev event to record how much seller earns\n   */\n  event EvProfit(bytes32 itemHash, address currency, address to, uint256 amount);\n\n  /**\n   * @dev event to record a item order matched\n   */\n  event EvInventory(\n    bytes32 indexed itemHash,\n    address maker,\n    address taker,\n    uint256 orderSalt,\n    uint256 settleSalt,\n    uint256 intent,\n    uint256 delegateType,\n    uint256 deadline,\n    IERC20Upgradeable currency,\n    Market.OrderItem item,\n    Market.SettleDetail detail\n  );\n\n  /**\n   * @dev event to record delegator contract change\n   */\n  event EvDelegate(address delegate, bool isRemoval);\n\n  /**\n   * @dev event to record currency supported change\n   */\n  event EvCurrency(IERC20Upgradeable currency, bool isRemoval);\n\n  /**\n   * @dev event to record fee update\n   */\n  event EvFeeCapUpdate(uint256 newValue);\n  /**\n   * @dev event to record a order canceled\n   */\n  event EvCancel(bytes32 indexed itemHash);\n  /**\n   * @dev event to record a order failing\n   */\n  event EvFailure(uint256 index, bytes error);\n\n  function runSingle(\n    Market.Order memory,\n    Market.SettleShared memory,\n    Market.SettleDetail memory\n  ) external returns (uint256);\n\n  function updateFeeCap(uint256) external;\n\n  function updateDelegates(address[] calldata, address[] calldata) external;\n\n  function updateCurrencies(IERC20Upgradeable[] calldata, IERC20Upgradeable[] calldata) external;\n\n  function run(Market.RunInput memory input) external payable;\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/secretShop/SecretShopStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport './MarketConsts.sol';\n\nabstract contract SecretShopStorage {\n  /**\n   * @dev fee Cap\n   */\n  uint256 public feeCapPct;\n  /**\n   * @dev DOMAIN_SEPARATOR for EIP712\n   */\n  bytes32 public domainSeparator;\n\n  IWETHUpgradable public weth;\n\n  uint256[47] private __gap;\n\n  /**\n   * @dev store delegator contract status\n   */\n  mapping(address => bool) public delegates;\n\n  /**\n   * @dev store currency supported\n   */\n  mapping(IERC20Upgradeable => bool) public currencies;\n\n  /**\n   * @dev store itemHash status\n   */\n  mapping(bytes32 => Market.InvStatus) public inventoryStatus;\n}\n"
    },
    "contracts/tests/SecretShopUpgradableAlter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport '../secretShop/SecretShopUpgradable.sol';\nimport '../secretShop/interfaces/IWETHUpgradable.sol';\n\ncontract SecretShopUpgradableAlter is SecretShopUpgradable {\n  function setWETH(IWETHUpgradable newAddr) public onlyOwner {\n    weth = newAddr;\n  }\n\n  /**\n   * @dev override to trigger error\n   */\n  function runSingle(\n    Market.Order memory,\n    Market.SettleShared memory,\n    Market.SettleDetail memory\n  ) external virtual override returns (uint256) {\n    require(msg.sender == address(this), 'SecretShop: unsafe call');\n    // force to revert\n    revert();\n  }\n}\n"
    },
    "contracts/secretShop/ERC1155Delegate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol';\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport '@openzeppelin/contracts/access/AccessControl.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport './MarketConsts.sol';\nimport './interfaces/IDelegate.sol';\n\ncontract ERC1155Delegate is IDelegate, AccessControl, IERC1155Receiver, ReentrancyGuard, Pausable {\n  bytes32 public constant DELEGATION_CALLER = keccak256('DELEGATION_CALLER');\n  bytes32 public constant PAUSABLE_CALLER = keccak256('PAUSABLE_CALLER');\n\n  /**\n   * @dev single item data\n   */\n  struct Pair {\n    uint256 salt;\n    IERC1155 token;\n    uint256 tokenId;\n    uint256 amount;\n  }\n\n  constructor() {\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n  }\n\n  /**\n   * @return delegateType the delegate's type\n   */\n  function delegateType() external pure override returns (uint256) {\n    return uint256(Market.DelegationType.ERC1155);\n  }\n\n  /**\n   * @dev Received function\n   */\n  function onERC1155BatchReceived(\n    address,\n    address,\n    uint256[] calldata,\n    uint256[] calldata,\n    bytes calldata\n  ) external pure override returns (bytes4) {\n    return this.onERC1155BatchReceived.selector;\n  }\n\n  /**\n   * @dev Received function\n   */\n  function onERC1155Received(\n    address,\n    address,\n    uint256,\n    uint256,\n    bytes calldata\n  ) external pure override returns (bytes4) {\n    return this.onERC1155Received.selector;\n  }\n\n  function pause() public onlyRole(PAUSABLE_CALLER) {\n    _pause();\n  }\n\n  function unpause() public onlyRole(PAUSABLE_CALLER) {\n    _unpause();\n  }\n\n  /**\n   * @dev decode data to the array of Pair\n   */\n  function decode(bytes calldata data) public pure returns (Pair[] memory) {\n    return abi.decode(data, (Pair[]));\n  }\n\n  /**\n   * @dev run the sell to transfer item\n   * @param seller address which sell the item\n   * @param buyer address which buy the item\n   * @param data the item's data, which will be decode as a array of Pair\n   */\n  function executeSell(\n    address seller,\n    address buyer,\n    bytes calldata data\n  ) public override nonReentrant onlyRole(DELEGATION_CALLER) whenNotPaused returns (bool) {\n    Pair[] memory pairs = decode(data);\n    for (uint256 i = 0; i < pairs.length; i++) {\n      Pair memory p = pairs[i];\n      p.token.safeTransferFrom(seller, buyer, p.tokenId, p.amount, new bytes(0));\n    }\n    return true;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "contracts/tests/P12AssetDemo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\nimport '../access/SafeOwnable.sol';\n\ncontract P12AssetDemo is ERC1155(''), SafeOwnable {\n  // Mapping from token ID to account balances\n  mapping(uint256 => mapping(address => uint256)) private _balances;\n\n  //\n  mapping(uint256 => uint256) public supply;\n\n  /**\n   * See {_mint}.\n   */\n  function mint(\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n  ) public onlyOwner {\n    _mint(to, id, amount, data);\n    supply[id] += amount;\n  }\n}\n"
    },
    "contracts/factory/P12CoinFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '../staking/interfaces/IP12MineUpgradeable.sol';\nimport '../staking/interfaces/IGaugeController.sol';\nimport './interfaces/IP12GameCoin.sol';\n\ncontract P12CoinFactoryStorage {\n  /**\n   * @dev p12 ERC20 address\n   */\n  address public p12;\n  /**\n   * @dev uniswap v2 Router address\n   */\n  IUniswapV2Router02 public uniswapRouter;\n  /**\n   * @dev uniswap v2 Factory address\n   */\n  IUniswapV2Factory public uniswapFactory;\n  /**\n   * @dev length of cast delay time is a linear function of percentage of additional issues,\n   * @dev delayK and delayB is the linear function's parameter which could be changed later\n   */\n  uint256 public delayK;\n  uint256 public delayB;\n\n  /**\n   * @dev a random hash value for calculate mintId\n   */\n  bytes32 internal _initHash;\n\n  uint256 public addLiquidityEffectiveTime;\n\n  /**\n   * @dev p12 staking contract\n   */\n  IP12MineUpgradeable public p12Mine;\n\n  address public dev;\n  IGaugeController public gaugeController;\n\n  uint256[40] private __gap;\n\n  // gameId => developer address\n  mapping(string => address) public allGames;\n  // gameCoinAddress => gameId\n  mapping(IP12GameCoin => string) public allGameCoins;\n  // gameCoinAddress => declareMintId => MintCoinInfo\n  mapping(IP12GameCoin => mapping(bytes32 => MintCoinInfo)) public coinMintRecords;\n  // gameCoinAddress => declareMintId\n  mapping(IP12GameCoin => bytes32) public preMintIds;\n\n  /**\n   * @dev struct of each mint request\n   */\n  struct MintCoinInfo {\n    uint256 amount;\n    uint256 unlockTimestamp;\n    bool executed;\n  }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/factory/interfaces/IP12GameCoin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IP12GameCoin is IERC20 {\n  /**\n   * @dev record the event that transfer coin with a off-chain account, which will be used when someone want to deposit his coin to off-chain game.\n   */\n  event TransferWithAccount(address recipient, string account, uint256 amount);\n\n  function mint(address to, uint256 amount) external;\n\n  function gameId() external view returns (string memory);\n\n  function gameCoinIconUrl() external view returns (string memory);\n\n  function transferWithAccount(\n    address recipient,\n    string memory account,\n    uint256 amount\n  ) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/factory/P12GameCoin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '../access/SafeOwnable.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol';\nimport './interfaces/IP12GameCoin.sol';\n\ncontract P12GameCoin is IP12GameCoin, ERC20, ERC20Burnable, SafeOwnable {\n  /**\n   * @dev Off-chain data, game id\n   */\n  string public override gameId;\n\n  /**\n   * @dev game coin's logo\n   */\n  string public override gameCoinIconUrl;\n\n  /**\n   * @param name_ game coin name\n   * @param symbol_ game coin symbol\n   * @param gameId_ gameId\n   * @param gameCoinIconUrl_ game coin icon's url\n   * @param amount_ amount of first minting\n   */\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    string memory gameId_,\n    string memory gameCoinIconUrl_,\n    uint256 amount_\n  ) ERC20(name_, symbol_) {\n    gameId = gameId_;\n    gameCoinIconUrl = gameCoinIconUrl_;\n    _mint(msg.sender, amount_);\n  }\n\n  /**\n   * @dev mint function, the Owner will only be factory contract\n   * @param to address which receive newly-minted coin\n   * @param amount amount of the minting\n   */\n  function mint(address to, uint256 amount) public override onlyOwner {\n    _mint(to, amount);\n  }\n\n  /**\n   * @dev transfer function for just a basic transfer with an off-chain account\n   * @dev called when a user want to deposit his coin from on-chain to off-chain\n   * @param recipient address which receive the coin, usually be custodian address\n   * @param account off-chain account\n   * @param amount amount of this transfer\n   */\n  function transferWithAccount(\n    address recipient,\n    string memory account,\n    uint256 amount\n  ) external override {\n    transfer(recipient, amount);\n    emit TransferWithAccount(recipient, account, amount);\n  }\n}\n"
    },
    "contracts/factory/P12CoinFactoryUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '../access/SafeOwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport './interfaces/IP12CoinFactoryUpgradeable.sol';\nimport '../staking/interfaces/IP12MineUpgradeable.sol';\nimport './P12CoinFactoryStorage.sol';\nimport '../staking/interfaces/IGaugeController.sol';\nimport './P12GameCoin.sol';\nimport './interfaces/IP12GameCoin.sol';\n\ncontract P12CoinFactoryUpgradeable is\n  P12CoinFactoryStorage,\n  UUPSUpgradeable,\n  IP12CoinFactoryUpgradeable,\n  SafeOwnableUpgradeable,\n  ReentrancyGuardUpgradeable,\n  PausableUpgradeable\n{\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  //============ External ============\n  /**\n   * @dev set dev address\n   * @param newDev new dev address\n   */\n  function setDev(address newDev) external virtual override onlyOwner {\n    require(newDev != address(0), 'P12Factory: address cannot be 0');\n    address oldDev = dev;\n    dev = newDev;\n    emit SetDev(oldDev, newDev);\n  }\n\n  /**\n   * @dev set p12mine contract address\n   * @param newP12Mine new p12mine address\n   */\n  function setP12Mine(IP12MineUpgradeable newP12Mine) external virtual override onlyOwner {\n    require(address(newP12Mine) != address(0), 'P12Factory: address cannot be 0');\n    IP12MineUpgradeable oldP12Mine = p12Mine;\n    p12Mine = newP12Mine;\n    emit SetP12Mine(oldP12Mine, newP12Mine);\n  }\n\n  /**\n   * @dev set gaugeController contract address\n   * @param newGaugeController new gaugeController address\n   */\n  function setGaugeController(IGaugeController newGaugeController) external virtual override onlyOwner {\n    require(address(newGaugeController) != address(0), 'P12Factory: address cannot be 0');\n    IGaugeController oldGaugeController = gaugeController;\n    gaugeController = newGaugeController;\n    emit SetGaugeController(oldGaugeController, newGaugeController);\n  }\n\n  /**\n   * @dev set p12Token address\n   * reserved only during development\n   * @param newP12Token new p12Token address\n   */\n  function setP12Token(address newP12Token) external virtual override onlyOwner {\n    require(newP12Token != address(0), 'P12Factory: address cannot be 0');\n    address oldP12Token = p12;\n    p12 = newP12Token;\n    emit SetP12Token(oldP12Token, newP12Token);\n  }\n\n  /**\n   * @dev set uniswapFactory address\n   * reserved only during development\n   * @param newUniswapFactory new UniswapFactory address\n   */\n  function setUniswapFactory(IUniswapV2Factory newUniswapFactory) external virtual override onlyOwner {\n    require(address(newUniswapFactory) != address(0), 'P12Factory: address cannot be 0');\n    IUniswapV2Factory oldUniswapFactory = uniswapFactory;\n    uniswapFactory = newUniswapFactory;\n    emit SetUniswapFactory(oldUniswapFactory, newUniswapFactory);\n  }\n\n  /**\n   * @dev set uniswapRouter address\n   * reserved only during development\n   * @param newUniswapRouter new uniswapRouter address\n   */\n  function setUniswapRouter(IUniswapV2Router02 newUniswapRouter) external virtual override onlyOwner {\n    require(address(newUniswapRouter) != address(0), 'P12Factory: address cannot be 0');\n    IUniswapV2Router02 oldUniswapRouter = uniswapRouter;\n    uniswapRouter = newUniswapRouter;\n    emit SetUniswapRouter(oldUniswapRouter, newUniswapRouter);\n  }\n\n  /**\n   * @dev create binding between game and developer, only called by p12 backend\n   * @param gameId game id\n   * @param developer developer address, who own this game\n   */\n  function register(string memory gameId, address developer) external virtual override onlyDev {\n    require(developer != address(0), 'P12Factory: address cannot be 0');\n    allGames[gameId] = developer;\n    emit RegisterGame(gameId, developer);\n  }\n\n  /**\n   * @dev developer first create their game coin\n   * @param name new game coin's name\n   * @param symbol game coin's symbol\n   * @param gameId the game's id\n   * @param gameCoinIconUrl game coin icon's url\n   * @param amountGameCoin how many coin first mint\n   * @param amountP12 how many P12 coin developer would stake\n   * @return gameCoinAddress the address of the new game coin\n   */\n  function create(\n    string memory name,\n    string memory symbol,\n    string memory gameId,\n    string memory gameCoinIconUrl,\n    uint256 amountGameCoin,\n    uint256 amountP12\n  ) external virtual override nonReentrant whenNotPaused returns (IP12GameCoin gameCoinAddress) {\n    require(msg.sender == allGames[gameId], 'P12Factory: no permit to create');\n    require(amountP12 > 0, 'P12Factory: not enough p12');\n    gameCoinAddress = _create(name, symbol, gameId, gameCoinIconUrl, amountGameCoin);\n    uint256 amountGameCoinDesired = amountGameCoin / 2;\n\n    IERC20Upgradeable(p12).safeTransferFrom(msg.sender, address(this), amountP12);\n\n    IERC20Upgradeable(address(gameCoinAddress)).safeApprove(address(uniswapRouter), amountGameCoinDesired);\n\n    uint256 liquidity0;\n    (, , liquidity0) = uniswapRouter.addLiquidity(\n      p12,\n      address(gameCoinAddress),\n      amountP12,\n      amountGameCoinDesired,\n      amountP12,\n      amountGameCoinDesired,\n      address(p12Mine),\n      getBlockTimestamp() + addLiquidityEffectiveTime\n    );\n    //get pair contract address\n    address pair = uniswapFactory.getPair(p12, address(gameCoinAddress));\n\n    // check address\n    require(pair != address(0), 'P12Factory: pair address error');\n\n    // get lpToken value\n    uint256 liquidity1 = IUniswapV2Pair(pair).balanceOf(address(p12Mine));\n    require(liquidity0 == liquidity1, 'P12Factory: liquidities not =');\n\n    // add pair address to Controller,100 is init weight\n    gaugeController.addGauge(pair, 0, 100);\n\n    // create a new pool and add staking info\n    p12Mine.addLpTokenInfoForGameCreator(pair, liquidity1, msg.sender);\n\n    allGameCoins[gameCoinAddress] = gameId;\n    emit CreateGameCoin(gameCoinAddress, gameId, amountP12);\n    return IP12GameCoin(gameCoinAddress);\n  }\n\n  /**\n   * @dev if developer want to mint after create coin, developer must declare first\n   * @param gameId game's id\n   * @param gameCoinAddress game coin's address\n   * @param amountGameCoin how many developer want to mint\n   * @param success whether the operation success\n   */\n  function queueMintCoin(\n    string memory gameId,\n    IP12GameCoin gameCoinAddress,\n    uint256 amountGameCoin\n  ) external virtual override nonReentrant whenNotPaused returns (bool success) {\n    require(msg.sender == allGames[gameId], 'P12Factory: have no permission');\n    require(compareStrings(allGameCoins[gameCoinAddress], gameId), 'P12Factory: wrong game id');\n    // Set the correct unlock time\n    uint256 time;\n    uint256 currentTimestamp = getBlockTimestamp();\n    bytes32 _preMintId = preMintIds[gameCoinAddress];\n    uint256 lastUnlockTimestamp = coinMintRecords[gameCoinAddress][_preMintId].unlockTimestamp;\n    if (currentTimestamp >= lastUnlockTimestamp) {\n      time = currentTimestamp;\n    } else {\n      time = lastUnlockTimestamp;\n    }\n\n    // minting fee for p12\n    uint256 p12Fee = getMintFee(gameCoinAddress, amountGameCoin);\n\n    // transfer the p12 to this contract\n    IERC20Upgradeable(p12).safeTransferFrom(msg.sender, address(this), p12Fee);\n\n    uint256 delayD = getMintDelay(gameCoinAddress, amountGameCoin);\n\n    bytes32 mintId = _hashOperation(gameCoinAddress, msg.sender, amountGameCoin, time, _initHash);\n    coinMintRecords[gameCoinAddress][mintId] = MintCoinInfo(amountGameCoin, delayD + time, false);\n\n    emit QueueMintCoin(mintId, gameCoinAddress, amountGameCoin, delayD + time, p12Fee);\n\n    return true;\n  }\n\n  /**\n   * @dev when time is up, anyone can call this function to make the mint executed\n   * @param gameCoinAddress address of the game coin\n   * @param mintId a unique id to identify a mint, developer can get it after declare\n   * @return bool whether the operation success\n   */\n  function executeMintCoin(IP12GameCoin gameCoinAddress, bytes32 mintId)\n    external\n    virtual\n    override\n    nonReentrant\n    whenNotPaused\n    returns (bool)\n  {\n    require(coinMintRecords[gameCoinAddress][mintId].unlockTimestamp != 0, 'P12Factory: non-existent mint');\n    // check if it has been executed\n    require(!coinMintRecords[gameCoinAddress][mintId].executed, 'P12Factory: mint executed');\n\n    uint256 time = getBlockTimestamp();\n\n    // check that the current time is greater than the unlock time\n    require(time > coinMintRecords[gameCoinAddress][mintId].unlockTimestamp, 'P12Factory: not time to mint');\n\n    // Modify status\n    coinMintRecords[gameCoinAddress][mintId].executed = true;\n\n    // transfer the gameCoin to this contract first\n\n    IP12GameCoin(gameCoinAddress).mint(address(this), coinMintRecords[gameCoinAddress][mintId].amount);\n\n    emit ExecuteMintCoin(mintId, gameCoinAddress, msg.sender);\n\n    return true;\n  }\n\n  /**\n   * @notice called when user want to withdraw his game coin from custodian address\n   * @param userAddress user's address\n   * @param gameCoinAddress gameCoin's address\n   * @param amountGameCoin how many user want to withdraw\n   */\n  function withdraw(\n    address userAddress,\n    IP12GameCoin gameCoinAddress,\n    uint256 amountGameCoin\n  ) external virtual override onlyDev returns (bool) {\n    IERC20Upgradeable(address(gameCoinAddress)).safeTransfer(userAddress, amountGameCoin);\n    emit Withdraw(userAddress, gameCoinAddress, amountGameCoin);\n    return true;\n  }\n\n  //============ Public ============\n  function pause() public onlyOwner {\n    _pause();\n  }\n\n  function unpause() public onlyOwner {\n    _unpause();\n  }\n\n  function initialize(\n    address p12_,\n    IUniswapV2Factory uniswapFactory_,\n    IUniswapV2Router02 uniswapRouter_,\n    uint256 effectiveTime_,\n    bytes32 initHash_\n  ) public initializer {\n    require(p12_ != address(0), 'P12Mine: p12 token cannot be 0');\n    require(address(uniswapFactory_) != address(0), 'P12Mine: uniswapF cannot be 0');\n    require(address(uniswapRouter_) != address(0), 'P12Mine: uniswapR cannot be 0');\n\n    p12 = p12_;\n    uniswapFactory = uniswapFactory_;\n    uniswapRouter = uniswapRouter_;\n    _initHash = initHash_;\n    addLiquidityEffectiveTime = effectiveTime_;\n    IERC20Upgradeable(p12).safeApprove(address(uniswapRouter), type(uint256).max);\n    __ReentrancyGuard_init_unchained();\n    __Pausable_init_unchained();\n    __Ownable_init_unchained();\n  }\n\n  /**\n   * @dev set linear function's K parameter\n   * @param newDelayK new K parameter\n   */\n  function setDelayK(uint256 newDelayK) public virtual override onlyOwner returns (bool) {\n    uint256 oldDelayK = delayK;\n    delayK = newDelayK;\n    emit SetDelayK(oldDelayK, delayK);\n    return true;\n  }\n\n  /**\n   * @dev set linear function's B parameter\n   * @param newDelayB new B parameter\n   */\n  function setDelayB(uint256 newDelayB) public virtual override onlyOwner returns (bool) {\n    uint256 oldDelayB = delayB;\n    delayB = newDelayB;\n    emit SetDelayB(oldDelayB, delayB);\n    return true;\n  }\n\n  /**\n   * @dev calculate the MintFee in P12\n   */\n  function getMintFee(IP12GameCoin gameCoinAddress, uint256 amountGameCoin)\n    public\n    view\n    virtual\n    override\n    returns (uint256 amountP12)\n  {\n    uint256 gameCoinReserved;\n    uint256 p12Reserved;\n    if (p12 < address(gameCoinAddress)) {\n      (p12Reserved, gameCoinReserved, ) = IUniswapV2Pair(uniswapFactory.getPair(address(gameCoinAddress), p12)).getReserves();\n    } else {\n      (gameCoinReserved, p12Reserved, ) = IUniswapV2Pair(uniswapFactory.getPair(address(gameCoinAddress), p12)).getReserves();\n    }\n\n    // overflow when p12Reserved * amountGameCoin > 2^256 ~= 10^77\n    amountP12 = (p12Reserved * amountGameCoin) / (gameCoinReserved * 100);\n\n    return amountP12;\n  }\n\n  /**\n   * @dev linear function to calculate the delay time\n   * @dev delayB is the minimum delay period, even someone mint zero token,\n   * @dev there still be delayB period before someone can really mint zero token\n   * @dev delayK is the parameter to take the ratio of new amount in to account\n   * @dev For example, the initial supply of Game Coin is 100k. If developer want\n   * @dev to mint 100k, developer needs to real mint it after `delayK + delayB`. If\n   * @dev developer want to mint 200k, developer has to real mint it after `2DelayK +\n   * @dev delayB`.\n          ^\n        t +            /\n          |          /\n          |        /\n      2k+b|      /\n          |    /\n       k+b|  / \n          |/ \n         b|\n          0----p---2p---------> amount\n            \n   */\n  function getMintDelay(IP12GameCoin gameCoinAddress, uint256 amountGameCoin)\n    public\n    view\n    virtual\n    override\n    returns (uint256 time)\n  {\n    time = (amountGameCoin * delayK) / (IP12GameCoin(gameCoinAddress).totalSupply()) + delayB;\n    return time;\n  }\n\n  //============ Internal ============\n\n  /**\n   * @dev function to create a game coin contract\n   * @param name game coin name\n   * @param symbol game coin symbol\n   * @param gameId game id\n   * @param gameCoinIconUrl game coin icon's url\n   * @param amountGameCoin how many for first mint\n   */\n  function _create(\n    string memory name,\n    string memory symbol,\n    string memory gameId,\n    string memory gameCoinIconUrl,\n    uint256 amountGameCoin\n  ) internal virtual returns (P12GameCoin gameCoinAddress) {\n    P12GameCoin gameCoin = new P12GameCoin(name, symbol, gameId, gameCoinIconUrl, amountGameCoin);\n    gameCoinAddress = gameCoin;\n  }\n\n  /**\n   * @dev hash function to general mintId\n   * @param gameCoinAddress game coin address\n   * @param declarer address which declare to mint game coin\n   * @param amount how much to mint\n   * @param timestamp time when declare\n   * @param salt a random bytes32\n   * @return hash mintId\n   */\n  function _hashOperation(\n    IP12GameCoin gameCoinAddress,\n    address declarer,\n    uint256 amount,\n    uint256 timestamp,\n    bytes32 salt\n  ) internal virtual returns (bytes32 hash) {\n    bytes32 preMintId = preMintIds[gameCoinAddress];\n\n    bytes32 preMintIdNew = keccak256(abi.encode(gameCoinAddress, declarer, amount, timestamp, preMintId, salt));\n    preMintIds[gameCoinAddress] = preMintIdNew;\n    return preMintIdNew;\n  }\n\n  function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n  /**\n   * @dev get current block's timestamp\n   */\n  function getBlockTimestamp() internal view virtual returns (uint256) {\n    return block.timestamp;\n  }\n\n  /**\n   * @dev compare two string and judge whether they are the same\n   */\n  function compareStrings(string memory a, string memory b) internal pure virtual returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n\n  // ============= Modifier ================\n  modifier onlyDev() {\n    require(msg.sender == dev, 'P12Factory: caller must be dev');\n    _;\n  }\n}\n"
    },
    "contracts/factory/interfaces/IP12CoinFactoryUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '../../staking/interfaces/IP12MineUpgradeable.sol';\nimport '../../staking/interfaces/IGaugeController.sol';\nimport './IP12GameCoin.sol';\n\ninterface IP12CoinFactoryUpgradeable {\n  // register gameId =>developer\n  function register(string memory gameId, address developer) external;\n\n  // mint game coin\n  function create(\n    string memory name,\n    string memory symbol,\n    string memory gameId,\n    string memory gameCoinIconUrl,\n    uint256 amountGameCoin,\n    uint256 amountP12\n  ) external returns (IP12GameCoin);\n\n  //  mint coin and Launch a statement\n  function queueMintCoin(\n    string memory gameId,\n    IP12GameCoin gameCoinAddress,\n    uint256 amountGameCoin\n  ) external returns (bool);\n\n  // execute Mint coin\n  function executeMintCoin(IP12GameCoin gameCoinAddress, bytes32 mintId) external returns (bool);\n\n  function withdraw(\n    address userAddress,\n    IP12GameCoin gameCoinAddress,\n    uint256 amountGameCoin\n  ) external returns (bool);\n\n  function setDev(address newDev) external;\n\n  function setP12Mine(IP12MineUpgradeable newP12Mine) external;\n\n  function setGaugeController(IGaugeController newGaugeController) external;\n\n  function setUniswapFactory(IUniswapV2Factory newUniswapFactory) external;\n\n  function setUniswapRouter(IUniswapV2Router02 newUniswapRouter) external;\n\n  function setP12Token(address newP12Token) external;\n\n  // get mintFee\n  function getMintFee(IP12GameCoin gameCoinAddress, uint256 amountGameCoin) external view returns (uint256);\n\n  // get mintDelay\n  function getMintDelay(IP12GameCoin gameCoinAddress, uint256 amountGameCoin) external view returns (uint256);\n\n  // get delayK\n  function setDelayK(uint256 delayK) external returns (bool);\n\n  // get delayB\n  function setDelayB(uint256 delayB) external returns (bool);\n\n  // register Game developer log\n  event RegisterGame(string gameId, address indexed developer);\n\n  // register Game coin log\n  event CreateGameCoin(IP12GameCoin indexed gameCoinAddress, string gameId, uint256 amountP12);\n\n  // mint coin in future log\n  event QueueMintCoin(\n    bytes32 indexed mintId,\n    IP12GameCoin indexed gameCoinAddress,\n    uint256 mintAmount,\n    uint256 unlockTimestamp,\n    uint256 amountP12\n  );\n\n  // mint coin success log\n  event ExecuteMintCoin(bytes32 indexed mintId, IP12GameCoin indexed gameCoinAddress, address indexed executor);\n\n  // game player withdraw gameCoin\n  event Withdraw(address userAddress, IP12GameCoin gameCoinAddress, uint256 amountGameCoin);\n\n  event SetDev(address oldDev, address newDev);\n\n  // p12Mine and GaugeController address change log\n  event SetP12Mine(IP12MineUpgradeable oldP12Mine, IP12MineUpgradeable newP12Mine);\n\n  event SetGaugeController(IGaugeController oldGaugeController, IGaugeController newGaugeController);\n\n  // uniFactory and router address change log\n  event SetUniswapFactory(IUniswapV2Factory oldUniswapFactory, IUniswapV2Factory newUniswapFactory);\n\n  event SetUniswapRouter(IUniswapV2Router02 oldUniswapRouter, IUniswapV2Router02 newUniswapRouter);\n\n  event SetP12Token(address oldP12Token, address newP12Token);\n\n  // change delayB log\n  event SetDelayB(uint256 oldDelayB, uint256 newDelayB);\n\n  // change delayK log\n  event SetDelayK(uint256 oldDelayK, uint256 newDelayK);\n}\n"
    },
    "contracts/tests/CoinFactoryUpgradeableAlter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport '../factory/P12CoinFactoryUpgradeable.sol';\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\n\n// new contract for test\ncontract P12CoinFactoryUpgradeableAlter is P12CoinFactoryUpgradeable {\n  /**\n   * @dev set UniswapFactory address\n   * @param newAddr new UniswapFactory address\n   */\n  function setUniswapFactory(IUniswapV2Factory newAddr) public override onlyOwner {\n    uniswapFactory = IUniswapV2Factory(newAddr);\n  }\n\n  /**\n   * @dev set Uniswap Router Address\n   * @param newAddr new Uniswap Router Address\n   */\n  function setUniswapRouter(IUniswapV2Router02 newAddr) public override onlyOwner {\n    uniswapRouter = IUniswapV2Router02(newAddr);\n  }\n\n  /**\n   * @dev this is used for test internal function upgrade\n   */\n  function compareStrings(string memory, string memory) internal pure override returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev public function to call internal function\n   */\n  function callWhiteBlack() public pure {\n    require(compareStrings('1', '2'), 'callWhiteBlack fail');\n  }\n}\n"
    },
    "contracts/assetFactory/P12AssetFactoryUpgradable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport './P12Asset.sol';\nimport '../factory/P12CoinFactoryUpgradeable.sol';\nimport './interfaces/IP12AssetFactoryUpgradable.sol';\nimport './P12AssetFactoryStorage.sol';\nimport '../access/SafeOwnableUpgradeable.sol';\n\ncontract P12AssetFactoryUpgradable is\n  P12AssetFactoryStorage,\n  IP12AssetFactoryUpgradable,\n  ReentrancyGuardUpgradeable,\n  SafeOwnableUpgradeable,\n  PausableUpgradeable,\n  UUPSUpgradeable\n{\n  // ============ External ============\n\n  /**\n  @notice set new p12CoinFactory\n  @param newP12CoinFactory address of p12CoinFactory\n   */\n  function setP12CoinFactory(address newP12CoinFactory) external virtual override onlyOwner {\n    address oldP12Factory = p12CoinFactory;\n    require(newP12CoinFactory != address(0), 'P12AssetF: p12CoinFactory cannot be 0');\n    p12CoinFactory = newP12CoinFactory;\n    emit SetP12Factory(oldP12Factory, newP12CoinFactory);\n  }\n\n  function pause() public onlyOwner {\n    _pause();\n  }\n\n  function unpause() public onlyOwner {\n    _unpause();\n  }\n\n  function initialize(address p12CoinFactory_) public initializer {\n    require(p12CoinFactory_ != address(0), 'P12AssetF: p12CoinFactory cannot be 0');\n    p12CoinFactory = p12CoinFactory_;\n\n    __ReentrancyGuard_init_unchained();\n    __Pausable_init_unchained();\n    __Ownable_init_unchained();\n  }\n\n  /**\n   * @dev create Collection\n   * @param gameId a off-chain game id\n   * @param contractURI contract-level metadata uri\n   */\n  function createCollection(string calldata gameId, string calldata contractURI)\n    public\n    override\n    onlyDeveloper(gameId)\n    whenNotPaused\n  {\n    P12Asset collection = new P12Asset(contractURI);\n    // record creator\n    registry[address(collection)] = gameId;\n\n    emit CollectionCreated(address(collection), msg.sender);\n  }\n\n  /**\n   * @dev create asset and mint to msg.sender address\n   * @param collection which collection want to create\n   * @param amount amount of asset\n   * @param uri new asset's metadata uri\n   */\n  function createAssetAndMint(\n    address collection,\n    uint256 amount,\n    string calldata uri\n  ) public override onlyCollectionDeveloper(collection) whenNotPaused nonReentrant {\n    // create\n    uint256 tokenId = P12Asset(collection).create(amount, uri);\n    // mint to developer address\n    P12Asset(collection).mint(msg.sender, tokenId, amount, new bytes(0));\n\n    emit SftCreated(address(collection), tokenId, amount);\n  }\n\n  /**\n   * @dev update Collection Uri\n   * @param collection collection address\n   * @param newUri new Contract-level metadata uri\n   */\n  function updateCollectionUri(address collection, string calldata newUri)\n    public\n    override\n    onlyCollectionDeveloper(collection)\n    whenNotPaused\n  {\n    P12Asset(collection).setContractURI(newUri);\n  }\n\n  /**\n   * @dev update Sft Uri\n   * @param collection collection address\n   * @param tokenId token id\n   * @param newUri new metadata uri\n   */\n  function updateSftUri(\n    address collection,\n    uint256 tokenId,\n    string calldata newUri\n  ) public override onlyCollectionDeveloper(collection) whenNotPaused {\n    P12Asset(collection).setUri(tokenId, newUri);\n  }\n\n  /** upgrade function */\n  function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n  modifier onlyDeveloper(string memory gameId) {\n    require(P12CoinFactoryUpgradeable(p12CoinFactory).allGames(gameId) == msg.sender, 'P12AssetF: not game developer');\n    _;\n  }\n\n  modifier onlyCollectionDeveloper(address collection) {\n    require(\n      P12CoinFactoryUpgradeable(p12CoinFactory).allGames(registry[collection]) == msg.sender,\n      'P12AssetF: not game developer'\n    );\n    _;\n  }\n}\n"
    },
    "contracts/assetFactory/P12Asset.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\nimport './interfaces/IP12Asset.sol';\nimport '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\nimport '../access/SafeOwnable.sol';\n\ncontract P12Asset is IP12Asset, ERC1155(''), SafeOwnable {\n  /**\n   * @dev contract-level metadata uri, refer to https://docs.opensea.io/docs/contract-level-metadata\n   */\n  string public contractURI;\n\n  /**\n   * @dev current supply, how many a id are minted not.\n   */\n  mapping(uint256 => uint256) public supply;\n\n  /**\n   * @dev max supply, a token id has a max supply cap\n   */\n  mapping(uint256 => uint256) public maxSupply;\n  /**\n   * @dev token id index, which will increase one by one\n   */\n  uint256 private idx = 0;\n\n  // Mapping from token ID to account balances\n  mapping(uint256 => mapping(address => uint256)) private _balances;\n\n  // metadata uri\n  mapping(uint256 => string) private _uri;\n\n  constructor(string memory contractURI_) {\n    require(bytes(contractURI_).length != 0, 'P12Asset: empty contractURI');\n    contractURI = contractURI_;\n  }\n\n  /**\n   * @dev developer create an new asset\n   * @param amount the new asset's totalSupply\n   * @param newUri metadata uri of the asset\n   * @return uint256 new asset's tokenId\n   */\n\n  function create(uint256 amount, string calldata newUri) public override onlyOwner returns (uint256) {\n    // set tokenId totalSupply\n    maxSupply[idx] = amount;\n    // set metadata Uri\n    _setUri(idx, newUri);\n    // idx increment\n    idx += 1;\n    return idx - 1;\n  }\n\n  /**\n   * @dev update token's metadata uri\n   * @param id tokenId\n   * @param newUri new uri\n   */\n  function setUri(uint256 id, string calldata newUri) public override onlyOwner {\n    _setUri(id, newUri);\n  }\n\n  /**\n   * See {_mint}.\n   */\n  function mint(\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n  ) public override onlyOwner {\n    require(id < idx, 'P12Asset: id is not valid');\n    require(amount + supply[id] <= maxSupply[id], 'P12Asset: exceed max supply');\n    _mint(to, id, amount, data);\n    supply[id] += amount;\n  }\n\n  /**\n   * @dev return token metadata uri\n   * @param id token's id\n   * @return uri metadata uri\n   */\n  function uri(uint256 id) public view virtual override returns (string memory) {\n    require(id < idx, 'P12Asset: id not exist');\n    return _uri[id];\n  }\n\n  /**\n   * @dev set contract-level MetaData\n   * @param newContractURI new Contract-level metadata uri\n   */\n  function setContractURI(string calldata newContractURI) public override onlyOwner {\n    require(bytes(newContractURI).length != 0, 'P12Asset: empty contractURI');\n    string memory oldContractURI = contractURI;\n    contractURI = newContractURI;\n    emit SetContractURI(oldContractURI, contractURI);\n  }\n\n  /**\n   * @dev set token metadata uri\n   * @param id  token id\n   * @param newUri metadata uri\n   */\n  function _setUri(uint256 id, string calldata newUri) private {\n    require(bytes(newUri).length != 0, 'P12Asset: empty uri');\n    require(id <= idx, 'P12Asset: id not exist');\n    _uri[id] = newUri;\n    emit SetUri(id, newUri);\n  }\n}\n"
    },
    "contracts/assetFactory/interfaces/IP12AssetFactoryUpgradable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\ninterface IP12AssetFactoryUpgradable {\n  /**\n   * @dev record a new Collection Created\n   */\n  event CollectionCreated(address indexed collection, address indexed developer);\n\n  /**\n   * @dev record a new Sft created, sft is semi-fungible token, as it's in a ERC1155 contract\n   */\n  event SftCreated(address indexed collection, uint256 indexed tokenId, uint256 amount);\n\n  event SetP12Factory(address oldP12Factory, address newP12Factory);\n\n  function setP12CoinFactory(address newP12Factory) external;\n\n  function createCollection(string calldata gameId, string calldata) external;\n\n  function createAssetAndMint(\n    address,\n    uint256,\n    string calldata\n  ) external;\n\n  function updateCollectionUri(address, string calldata) external;\n\n  function updateSftUri(\n    address,\n    uint256,\n    string calldata\n  ) external;\n}\n"
    },
    "contracts/assetFactory/P12AssetFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\ncontract P12AssetFactoryStorage {\n  /**\n    @dev collection address => gameId\n  */\n  mapping(address => string) public registry;\n\n  /**\n   * p12CoinFactory address, for reading game and developer relationship\n   */\n  address public p12CoinFactory;\n\n  uint256[49] private __gap;\n}\n"
    },
    "contracts/assetFactory/interfaces/IP12Asset.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.15;\n\ninterface IP12Asset {\n  /**\n   * @dev Update log of contract-level MetaData\n   */\n  event SetContractURI(string oldContractURI, string newContractURI);\n\n  /**\n   * @dev log of token metadata uri\n   */\n  event SetUri(uint256 id, string uri);\n\n  function create(uint256, string calldata) external returns (uint256);\n\n  function mint(\n    address,\n    uint256,\n    uint256,\n    bytes memory\n  ) external;\n\n  function setContractURI(string calldata) external;\n\n  function setUri(uint256, string calldata) external;\n}\n"
    },
    "contracts/tests/P12AssetFactoryUpgradableAlter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport '../assetFactory/P12AssetFactoryUpgradable.sol';\n\ncontract P12AssetFactoryUpgradableAlter is P12AssetFactoryUpgradable {}\n"
    },
    "contracts/tests/ERC721Demo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '../access/SafeOwnable.sol';\n\ncontract ERC721Demo is ERC721('', ''), SafeOwnable {\n  /**\n   * See {_mint}.\n   */\n  function safeMint(\n    address to,\n    uint256 id,\n    bytes memory data\n  ) public onlyOwner {\n    _safeMint(to, id, data);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}